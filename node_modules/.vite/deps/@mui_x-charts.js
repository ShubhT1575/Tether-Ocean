import {
  ChartContainer,
  ChartsAxis,
  ChartsAxisHighlight,
  ChartsAxisHighlightPath,
  ChartsAxisTooltipContent,
  ChartsItemTooltipContent,
  ChartsLegend,
  ChartsOverlay,
  ChartsSurface,
  ChartsText,
  ChartsTooltip,
  ChartsTooltipCell,
  ChartsTooltipMark,
  ChartsTooltipPaper,
  ChartsTooltipRow,
  ChartsTooltipTable,
  ChartsXAxis,
  ChartsYAxis,
  ContinuousColorLegend,
  DefaultChartsAxisTooltipContent,
  DefaultChartsItemTooltipContent,
  DefaultChartsLegend,
  HighlightedContext,
  HighlightedProvider,
  InteractionContext,
  PieArc,
  PieArcLabel,
  PieArcLabelPlot,
  PieArcPlot,
  PieChart,
  PiePlot,
  PiecewiseColorLegend,
  ResponsiveChartContainer,
  animated,
  axisClasses,
  chartsAxisHighlightClasses,
  chartsTooltipClasses,
  getAxisHighlightUtilityClass,
  getAxisUtilityClass,
  getChartsTooltipUtilityClass,
  getLegendUtilityClass,
  getPercentageValue,
  getPieArcLabelUtilityClass,
  getPieArcUtilityClass,
  getPieCoordinates,
  getSVGPoint,
  getSeriesToDisplay,
  legendClasses,
  pieArcClasses,
  pieArcLabelClasses,
  to,
  useAxisTooltip,
  useChartContainerDimensions,
  useChartGradient,
  useHighlighted,
  useInteractionItemProps,
  useItemHighlighted,
  useItemTooltip,
  useMouseTracker,
  useSkipAnimation,
  useSpring,
  useTransition
} from "./chunk-XRUULXJ2.js";
import "./chunk-RMQ5VGHH.js";
import {
  DEFAULT_MARGINS,
  DEFAULT_X_AXIS_KEY,
  DEFAULT_Y_AXIS_KEY,
  DrawingProvider,
  ZAxisContext,
  ZAxisContextProvider,
  blueberryTwilightPalette,
  blueberryTwilightPaletteDark,
  blueberryTwilightPaletteLight,
  cheerfulFiestaPalette,
  cheerfulFiestaPaletteDark,
  cheerfulFiestaPaletteLight,
  getColor_default,
  getColor_default2,
  getColor_default3,
  getValueToPositionMapper,
  isBandScaleConfig,
  isPointScaleConfig,
  mangoFusionPalette,
  mangoFusionPaletteDark,
  mangoFusionPaletteLight,
  useBarSeries,
  useCartesianContext,
  useChartId,
  useDrawingArea,
  useLineSeries,
  usePieSeries,
  useScatterSeries,
  useSeries,
  useSvgRef,
  useTicks,
  useXAxis,
  useXColorScale,
  useXScale,
  useYAxis,
  useYColorScale,
  useYScale,
  useZColorScale,
  warnOnce
} from "./chunk-NL22UTAN.js";
import {
  useThemeProps
} from "./chunk-DEFXXUJU.js";
import {
  Delaunay
} from "./chunk-ZDBHR3XO.js";
import {
  Symbol,
  arc_default,
  area_default,
  catmullRom_default,
  color,
  line_default,
  linear_default,
  monotoneX,
  monotoneY,
  natural_default,
  stepAfter,
  stepBefore,
  step_default,
  string_default,
  symbolsFill
} from "./chunk-JZ73OIR6.js";
import {
  _objectWithoutPropertiesLoose
} from "./chunk-YR5LAKKR.js";
import "./chunk-SM3OW2QE.js";
import "./chunk-UNWQHY2U.js";
import "./chunk-5RJLINHO.js";
import "./chunk-TJRV5NWC.js";
import {
  useTheme
} from "./chunk-AGZJNRQX.js";
import {
  _extends,
  composeClasses,
  generateUtilityClass,
  generateUtilityClasses,
  styled_default,
  useEnhancedEffect_default,
  useForkRef,
  useId,
  useSlotProps_default
} from "./chunk-4UEFB6FL.js";
import {
  require_prop_types
} from "./chunk-UGAOOQDA.js";
import {
  clsx_default
} from "./chunk-VEB3A3D5.js";
import {
  require_jsx_runtime
} from "./chunk-6PF5PHNV.js";
import {
  require_react
} from "./chunk-7SNDHR3H.js";
import {
  __toESM
} from "./chunk-256EKJAK.js";

// node_modules/@mui/x-charts/models/seriesType/index.js
function isDefaultizedBarSeries(series) {
  return series.type === "bar";
}
function isBarSeries(series) {
  return series.type === "bar";
}

// node_modules/@mui/x-charts/ChartsClipPath/ChartsClipPath.js
var React = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var import_jsx_runtime = __toESM(require_jsx_runtime());
function ChartsClipPath(props) {
  const {
    id,
    offset: offsetProps
  } = props;
  const {
    left,
    top,
    width,
    height
  } = useDrawingArea();
  const offset = _extends({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, offsetProps);
  return (0, import_jsx_runtime.jsx)("clipPath", {
    id,
    children: (0, import_jsx_runtime.jsx)("rect", {
      x: left - offset.left,
      y: top - offset.top,
      width: width + offset.left + offset.right,
      height: height + offset.top + offset.bottom
    })
  });
}
true ? ChartsClipPath.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  id: import_prop_types.default.string.isRequired,
  offset: import_prop_types.default.shape({
    bottom: import_prop_types.default.number,
    left: import_prop_types.default.number,
    right: import_prop_types.default.number,
    top: import_prop_types.default.number
  })
} : void 0;

// node_modules/@mui/x-charts/ChartsReferenceLine/ChartsReferenceLine.js
var React4 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/ChartsReferenceLine/ChartsXReferenceLine.js
var React2 = __toESM(require_react());

// node_modules/@mui/x-charts/ChartsReferenceLine/chartsReferenceLineClasses.js
function getReferenceLineUtilityClass(slot) {
  return generateUtilityClass("MuiChartsReferenceLine", slot);
}
var referenceLineClasses = generateUtilityClasses("MuiChartsReferenceLine", ["root", "vertical", "horizontal", "line", "label"]);

// node_modules/@mui/x-charts/ChartsReferenceLine/common.js
var ReferenceLineRoot = styled_default("g")(({
  theme
}) => ({
  [`& .${referenceLineClasses.line}`]: {
    fill: "none",
    stroke: (theme.vars || theme).palette.text.primary,
    shapeRendering: "crispEdges",
    strokeWidth: 1,
    pointerEvents: "none"
  },
  [`& .${referenceLineClasses.label}`]: _extends({
    fill: (theme.vars || theme).palette.text.primary,
    stroke: "none",
    pointerEvents: "none",
    fontSize: 12
  }, theme.typography.body1)
}));

// node_modules/@mui/x-charts/ChartsReferenceLine/ChartsXReferenceLine.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var getTextParams = ({
  top,
  height,
  spacingY,
  labelAlign = "middle"
}) => {
  switch (labelAlign) {
    case "start":
      return {
        y: top + spacingY,
        style: {
          dominantBaseline: "hanging",
          textAnchor: "start"
        }
      };
    case "end":
      return {
        y: top + height - spacingY,
        style: {
          dominantBaseline: "auto",
          textAnchor: "start"
        }
      };
    default:
      return {
        y: top + height / 2,
        style: {
          dominantBaseline: "central",
          textAnchor: "start"
        }
      };
  }
};
function getXReferenceLineClasses(classes) {
  return composeClasses({
    root: ["root", "vertical"],
    line: ["line"],
    label: ["label"]
  }, getReferenceLineUtilityClass, classes);
}
function ChartsXReferenceLine(props) {
  const {
    x,
    label = "",
    spacing = 5,
    classes: inClasses,
    labelAlign,
    lineStyle,
    labelStyle,
    axisId
  } = props;
  const {
    top,
    height
  } = useDrawingArea();
  const xAxisScale = useXScale(axisId);
  const xPosition = xAxisScale(x);
  if (xPosition === void 0) {
    if (true) {
      warnOnce(`MUI X: the value ${x} does not exist in the data of x axis with id ${axisId}.`, "error");
    }
    return null;
  }
  const d = `M ${xPosition} ${top} l 0 ${height}`;
  const classes = getXReferenceLineClasses(inClasses);
  const spacingX = typeof spacing === "object" ? spacing.x ?? 0 : spacing;
  const spacingY = typeof spacing === "object" ? spacing.y ?? 0 : spacing;
  const textParams = _extends({
    x: xPosition + spacingX,
    text: label,
    fontSize: 12
  }, getTextParams({
    top,
    height,
    spacingY,
    labelAlign
  }), {
    className: classes.label
  });
  return (0, import_jsx_runtime2.jsxs)(ReferenceLineRoot, {
    className: classes.root,
    children: [(0, import_jsx_runtime2.jsx)("path", {
      d,
      className: classes.line,
      style: lineStyle
    }), (0, import_jsx_runtime2.jsx)(ChartsText, _extends({}, textParams, {
      style: _extends({}, textParams.style, labelStyle)
    }))]
  });
}

// node_modules/@mui/x-charts/ChartsReferenceLine/ChartsYReferenceLine.js
var React3 = __toESM(require_react());
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var getTextParams2 = ({
  left,
  width,
  spacingX,
  labelAlign = "middle"
}) => {
  switch (labelAlign) {
    case "start":
      return {
        x: left + spacingX,
        style: {
          dominantBaseline: "auto",
          textAnchor: "start"
        }
      };
    case "end":
      return {
        x: left + width - spacingX,
        style: {
          dominantBaseline: "auto",
          textAnchor: "end"
        }
      };
    default:
      return {
        x: left + width / 2,
        style: {
          dominantBaseline: "auto",
          textAnchor: "middle"
        }
      };
  }
};
function getYReferenceLineClasses(classes) {
  return composeClasses({
    root: ["root", "horizontal"],
    line: ["line"],
    label: ["label"]
  }, getReferenceLineUtilityClass, classes);
}
function ChartsYReferenceLine(props) {
  const {
    y,
    label = "",
    spacing = 5,
    classes: inClasses,
    labelAlign,
    lineStyle,
    labelStyle,
    axisId
  } = props;
  const {
    left,
    width
  } = useDrawingArea();
  const yAxisScale = useYScale(axisId);
  const yPosition = yAxisScale(y);
  if (yPosition === void 0) {
    if (true) {
      warnOnce(`MUI X: the value ${y} does not exist in the data of y axis with id ${axisId}.`, "error");
    }
    return null;
  }
  const d = `M ${left} ${yPosition} l ${width} 0`;
  const classes = getYReferenceLineClasses(inClasses);
  const spacingX = typeof spacing === "object" ? spacing.x ?? 0 : spacing;
  const spacingY = typeof spacing === "object" ? spacing.y ?? 0 : spacing;
  const textParams = _extends({
    y: yPosition - spacingY,
    text: label,
    fontSize: 12
  }, getTextParams2({
    left,
    width,
    spacingX,
    labelAlign
  }), {
    className: classes.label
  });
  return (0, import_jsx_runtime3.jsxs)(ReferenceLineRoot, {
    className: classes.root,
    children: [(0, import_jsx_runtime3.jsx)("path", {
      d,
      className: classes.line,
      style: lineStyle
    }), (0, import_jsx_runtime3.jsx)(ChartsText, _extends({}, textParams, {
      style: _extends({}, textParams.style, labelStyle)
    }))]
  });
}

// node_modules/@mui/x-charts/ChartsReferenceLine/ChartsReferenceLine.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
function ChartsReferenceLine(props) {
  const {
    x,
    y
  } = props;
  if (x !== void 0 && y !== void 0) {
    throw new Error("MUI X: The ChartsReferenceLine cannot have both `x` and `y` props set.");
  }
  if (x === void 0 && y === void 0) {
    throw new Error("MUI X: The ChartsReferenceLine should have a value in `x` or `y` prop.");
  }
  if (x !== void 0) {
    return (0, import_jsx_runtime4.jsx)(ChartsXReferenceLine, _extends({}, props));
  }
  return (0, import_jsx_runtime4.jsx)(ChartsYReferenceLine, _extends({}, props));
}
true ? ChartsReferenceLine.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The id of the axis used for the reference value.
   * @default The `id` of the first defined axis.
   */
  axisId: import_prop_types2.default.oneOfType([import_prop_types2.default.number, import_prop_types2.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types2.default.object,
  /**
   * The label to display along the reference line.
   */
  label: import_prop_types2.default.string,
  /**
   * The alignment if the label is in the chart drawing area.
   * @default 'middle'
   */
  labelAlign: import_prop_types2.default.oneOf(["end", "middle", "start"]),
  /**
   * The style applied to the label.
   */
  labelStyle: import_prop_types2.default.object,
  /**
   * The style applied to the line.
   */
  lineStyle: import_prop_types2.default.object,
  /**
   * Additional space around the label in px.
   * Can be a number or an object `{ x, y }` to distinguish space with the reference line and space with axes.
   * @default 5
   */
  spacing: import_prop_types2.default.oneOfType([import_prop_types2.default.number, import_prop_types2.default.shape({
    x: import_prop_types2.default.number,
    y: import_prop_types2.default.number
  })]),
  /**
   * The x value associated with the reference line.
   * If defined the reference line will be vertical.
   */
  x: import_prop_types2.default.oneOfType([import_prop_types2.default.instanceOf(Date), import_prop_types2.default.number, import_prop_types2.default.string]),
  /**
   * The y value associated with the reference line.
   * If defined the reference line will be horizontal.
   */
  y: import_prop_types2.default.oneOfType([import_prop_types2.default.instanceOf(Date), import_prop_types2.default.number, import_prop_types2.default.string])
} : void 0;

// node_modules/@mui/x-charts/ChartsGrid/ChartsGrid.js
var React7 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/ChartsGrid/chartsGridClasses.js
function getChartsGridUtilityClass(slot) {
  return generateUtilityClass("MuiChartsGrid", slot);
}
var chartsGridClasses = generateUtilityClasses("MuiChartsGrid", ["root", "line", "horizontalLine", "verticalLine"]);

// node_modules/@mui/x-charts/ChartsGrid/styledCommonents.js
var GridRoot = styled_default("g", {
  name: "MuiChartsGrid",
  slot: "Root",
  overridesResolver: (props, styles) => [{
    [`&.${chartsGridClasses.verticalLine}`]: styles.verticalLine
  }, {
    [`&.${chartsGridClasses.horizontalLine}`]: styles.horizontalLine
  }, styles.root]
})({});
var GridLine = styled_default("line", {
  name: "MuiChartsGrid",
  slot: "Line",
  overridesResolver: (props, styles) => styles.line
})(({
  theme
}) => ({
  stroke: (theme.vars || theme).palette.divider,
  shapeRendering: "crispEdges",
  strokeWidth: 1
}));

// node_modules/@mui/x-charts/ChartsGrid/ChartsVerticalGrid.js
var React5 = __toESM(require_react());
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
function ChartsGridVertical(props) {
  const {
    axis,
    drawingArea,
    classes
  } = props;
  const {
    scale,
    tickNumber,
    tickInterval
  } = axis;
  const xTicks = useTicks({
    scale,
    tickNumber,
    tickInterval
  });
  return (0, import_jsx_runtime5.jsx)(React5.Fragment, {
    children: xTicks.map(({
      formattedValue,
      offset
    }) => (0, import_jsx_runtime5.jsx)(GridLine, {
      y1: drawingArea.top,
      y2: drawingArea.top + drawingArea.height,
      x1: offset,
      x2: offset,
      className: classes.verticalLine
    }, `vertical-${formattedValue}`))
  });
}

// node_modules/@mui/x-charts/ChartsGrid/ChartsHorizontalGrid.js
var React6 = __toESM(require_react());
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
function ChartsGridHorizontal(props) {
  const {
    axis,
    drawingArea,
    classes
  } = props;
  const {
    scale,
    tickNumber,
    tickInterval
  } = axis;
  const yTicks = useTicks({
    scale,
    tickNumber,
    tickInterval
  });
  return (0, import_jsx_runtime6.jsx)(React6.Fragment, {
    children: yTicks.map(({
      formattedValue,
      offset
    }) => (0, import_jsx_runtime6.jsx)(GridLine, {
      y1: offset,
      y2: offset,
      x1: drawingArea.left,
      x2: drawingArea.left + drawingArea.width,
      className: classes.horizontalLine
    }, `horizontal-${formattedValue}`))
  });
}

// node_modules/@mui/x-charts/ChartsGrid/ChartsGrid.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var _excluded = ["vertical", "horizontal"];
var useUtilityClasses = ({
  classes
}) => {
  const slots = {
    root: ["root"],
    verticalLine: ["line", "verticalLine"],
    horizontalLine: ["line", "horizontalLine"]
  };
  return composeClasses(slots, getChartsGridUtilityClass, classes);
};
function ChartsGrid(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiChartsGrid"
  });
  const drawingArea = useDrawingArea();
  const {
    vertical,
    horizontal
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
  const {
    xAxis,
    xAxisIds,
    yAxis,
    yAxisIds
  } = useCartesianContext();
  const classes = useUtilityClasses(props);
  const horizontalAxis = yAxis[yAxisIds[0]];
  const verticalAxis = xAxis[xAxisIds[0]];
  return (0, import_jsx_runtime7.jsxs)(GridRoot, _extends({}, other, {
    className: classes.root,
    children: [vertical && (0, import_jsx_runtime7.jsx)(ChartsGridVertical, {
      axis: verticalAxis,
      drawingArea,
      classes
    }), horizontal && (0, import_jsx_runtime7.jsx)(ChartsGridHorizontal, {
      axis: horizontalAxis,
      drawingArea,
      classes
    })]
  }));
}
true ? ChartsGrid.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types3.default.object,
  /**
   * Displays horizontal grid.
   */
  horizontal: import_prop_types3.default.bool,
  /**
   * Displays vertical grid.
   */
  vertical: import_prop_types3.default.bool
} : void 0;

// node_modules/@mui/x-charts/ChartsVoronoiHandler/ChartsVoronoiHandler.js
var React8 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
function ChartsVoronoiHandler(props) {
  const {
    voronoiMaxRadius,
    onItemClick
  } = props;
  const svgRef = useSvgRef();
  const drawingArea = useDrawingArea();
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = useCartesianContext();
  const {
    dispatch
  } = React8.useContext(InteractionContext);
  const {
    series,
    seriesOrder
  } = useScatterSeries() ?? {};
  const voronoiRef = React8.useRef({});
  const delauneyRef = React8.useRef(void 0);
  const lastFind = React8.useRef(void 0);
  const {
    setHighlighted,
    clearHighlighted
  } = useHighlighted();
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  useEnhancedEffect_default(() => {
    dispatch({
      type: "updateVoronoiUsage",
      useVoronoiInteraction: true
    });
    return () => {
      dispatch({
        type: "updateVoronoiUsage",
        useVoronoiInteraction: false
      });
    };
  }, [dispatch]);
  useEnhancedEffect_default(() => {
    if (seriesOrder === void 0 || series === void 0) {
      return;
    }
    voronoiRef.current = {};
    let points = [];
    seriesOrder.forEach((seriesId) => {
      const {
        data,
        xAxisId,
        yAxisId,
        xAxisKey,
        yAxisKey
      } = series[seriesId];
      const xScale = xAxis[xAxisId ?? xAxisKey ?? defaultXAxisId].scale;
      const yScale = yAxis[yAxisId ?? yAxisKey ?? defaultYAxisId].scale;
      const getXPosition = getValueToPositionMapper(xScale);
      const getYPosition = getValueToPositionMapper(yScale);
      const seriesPoints = data.flatMap(({
        x,
        y
      }) => {
        const pointX = getXPosition(x);
        const pointY = getYPosition(y);
        if (!drawingArea.isPointInside({
          x: pointX,
          y: pointY
        })) {
          return [-drawingArea.width, -drawingArea.height];
        }
        return [pointX, pointY];
      });
      voronoiRef.current[seriesId] = {
        seriesId,
        startIndex: points.length,
        endIndex: points.length + seriesPoints.length
      };
      points = points.concat(seriesPoints);
    });
    delauneyRef.current = new Delaunay(points);
    lastFind.current = void 0;
  }, [defaultXAxisId, defaultYAxisId, series, seriesOrder, xAxis, yAxis, drawingArea]);
  React8.useEffect(() => {
    const element = svgRef.current;
    if (element === null) {
      return void 0;
    }
    function getClosestPoint(event) {
      const svgPoint = getSVGPoint(element, event);
      if (!drawingArea.isPointInside(svgPoint)) {
        lastFind.current = void 0;
        return "outside-chart";
      }
      if (!delauneyRef.current) {
        return "no-point-found";
      }
      const closestPointIndex = delauneyRef.current.find(svgPoint.x, svgPoint.y, lastFind.current);
      if (closestPointIndex === void 0) {
        return "no-point-found";
      }
      lastFind.current = closestPointIndex;
      const closestSeries = Object.values(voronoiRef.current).find((value) => {
        return 2 * closestPointIndex >= value.startIndex && 2 * closestPointIndex < value.endIndex;
      });
      if (closestSeries === void 0) {
        return "no-point-found";
      }
      const dataIndex = (2 * closestPointIndex - voronoiRef.current[closestSeries.seriesId].startIndex) / 2;
      if (voronoiMaxRadius !== void 0) {
        const pointX = delauneyRef.current.points[2 * closestPointIndex];
        const pointY = delauneyRef.current.points[2 * closestPointIndex + 1];
        const dist2 = (pointX - svgPoint.x) ** 2 + (pointY - svgPoint.y) ** 2;
        if (dist2 > voronoiMaxRadius ** 2) {
          return "outside-voronoi-max-radius";
        }
      }
      return {
        seriesId: closestSeries.seriesId,
        dataIndex
      };
    }
    const handleMouseLeave = () => {
      dispatch({
        type: "exitChart"
      });
      clearHighlighted();
    };
    const handleMouseMove = (event) => {
      const closestPoint = getClosestPoint(event);
      if (closestPoint === "outside-chart") {
        dispatch({
          type: "exitChart"
        });
        clearHighlighted();
        return;
      }
      if (closestPoint === "outside-voronoi-max-radius" || closestPoint === "no-point-found") {
        dispatch({
          type: "leaveItem",
          data: {
            type: "scatter"
          }
        });
        clearHighlighted();
        return;
      }
      const {
        seriesId,
        dataIndex
      } = closestPoint;
      dispatch({
        type: "enterItem",
        data: {
          type: "scatter",
          seriesId,
          dataIndex
        }
      });
      setHighlighted({
        seriesId,
        dataIndex
      });
    };
    const handleMouseClick = (event) => {
      if (!onItemClick) {
        return;
      }
      const closestPoint = getClosestPoint(event);
      if (typeof closestPoint === "string") {
        return;
      }
      const {
        seriesId,
        dataIndex
      } = closestPoint;
      onItemClick(event, {
        type: "scatter",
        seriesId,
        dataIndex
      });
    };
    element.addEventListener("pointerleave", handleMouseLeave);
    element.addEventListener("pointermove", handleMouseMove);
    element.addEventListener("click", handleMouseClick);
    return () => {
      element.removeEventListener("pointerleave", handleMouseLeave);
      element.removeEventListener("pointermove", handleMouseMove);
      element.removeEventListener("click", handleMouseClick);
    };
  }, [svgRef, dispatch, yAxis, xAxis, voronoiMaxRadius, onItemClick, setHighlighted, clearHighlighted, drawingArea]);
  return (0, import_jsx_runtime8.jsx)(React8.Fragment, {});
}
true ? ChartsVoronoiHandler.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when clicking on a scatter item.
   * @param {MouseEvent} event Mouse event caught at the svg level
   * @param {ScatterItemIdentifier} scatterItemIdentifier Identify which item got clicked
   */
  onItemClick: import_prop_types4.default.func,
  /**
   * Defines the maximal distance between a scatter point and the pointer that triggers the interaction.
   * If `undefined`, the radius is assumed to be infinite.
   */
  voronoiMaxRadius: import_prop_types4.default.number
} : void 0;

// node_modules/@mui/x-charts/ChartsOnAxisClickHandler/ChartsOnAxisClickHandler.js
var React9 = __toESM(require_react());
var import_prop_types5 = __toESM(require_prop_types());
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
function ChartsOnAxisClickHandler(props) {
  const {
    onAxisClick
  } = props;
  const svgRef = useSvgRef();
  const series = useSeries();
  const {
    axis
  } = React9.useContext(InteractionContext);
  const {
    xAxisIds,
    xAxis,
    yAxisIds,
    yAxis
  } = useCartesianContext();
  React9.useEffect(() => {
    const element = svgRef.current;
    if (element === null || !onAxisClick) {
      return () => {
      };
    }
    const handleMouseClick = (event) => {
      var _a;
      event.preventDefault();
      const isXaxis = axis.x && axis.x.index !== -1;
      const USED_AXIS_ID = isXaxis ? xAxisIds[0] : yAxisIds[0];
      const dataIndex = isXaxis ? axis.x && axis.x.index : axis.y && axis.y.index;
      if (dataIndex == null) {
        return;
      }
      const seriesValues = {};
      Object.keys(series).filter((seriesType) => ["bar", "line"].includes(seriesType)).forEach((seriesType) => {
        var _a2;
        (_a2 = series[seriesType]) == null ? void 0 : _a2.seriesOrder.forEach((seriesId) => {
          const seriesItem = series[seriesType].series[seriesId];
          const providedXAxisId = seriesItem.xAxisId ?? seriesItem.xAxisKey;
          const providedYAxisId = seriesItem.yAxisId ?? seriesItem.yAxisKey;
          const axisKey = isXaxis ? providedXAxisId : providedYAxisId;
          if (axisKey === void 0 || axisKey === USED_AXIS_ID) {
            seriesValues[seriesId] = seriesItem.data[dataIndex];
          }
        });
      });
      const axisValue = (_a = (isXaxis ? xAxis : yAxis)[USED_AXIS_ID].data) == null ? void 0 : _a[dataIndex];
      onAxisClick(event, {
        dataIndex,
        axisValue,
        seriesValues
      });
    };
    element.addEventListener("click", handleMouseClick);
    return () => {
      element.removeEventListener("click", handleMouseClick);
    };
  }, [axis.x, axis.y, onAxisClick, series, svgRef, xAxis, xAxisIds, yAxis, yAxisIds]);
  return (0, import_jsx_runtime9.jsx)(React9.Fragment, {});
}
true ? ChartsOnAxisClickHandler.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | AxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types5.default.func
} : void 0;

// node_modules/@mui/x-charts/BarChart/BarChart.js
var React16 = __toESM(require_react());
var import_prop_types10 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/BarChart/BarPlot.js
var React15 = __toESM(require_react());
var import_prop_types9 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/BarChart/BarElement.js
var React10 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var _excluded2 = ["id", "dataIndex", "classes", "color", "slots", "slotProps", "style", "onClick"];
function getBarElementUtilityClass(slot) {
  return generateUtilityClass("MuiBarElement", slot);
}
var barElementClasses = generateUtilityClasses("MuiBarElement", ["root"]);
var useUtilityClasses2 = (ownerState) => {
  const {
    classes,
    id
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`]
  };
  return composeClasses(slots, getBarElementUtilityClass, classes);
};
var BarElementPath = styled_default(animated.rect, {
  name: "MuiBarElement",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  ownerState
}) => ({
  stroke: "none",
  fill: ownerState.isHighlighted ? color(ownerState.color).brighter(0.5).formatHex() : ownerState.color,
  transition: "opacity 0.2s ease-in, fill 0.2s ease-in",
  opacity: ownerState.isFaded && 0.3 || 1
}));
function BarElement(props) {
  const {
    id,
    dataIndex,
    classes: innerClasses,
    color: color2,
    slots,
    slotProps,
    style,
    onClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
  const getInteractionItemProps = useInteractionItemProps();
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId: id,
    dataIndex
  });
  const ownerState = {
    id,
    dataIndex,
    classes: innerClasses,
    color: color2,
    isFaded,
    isHighlighted
  };
  const classes = useUtilityClasses2(ownerState);
  const Bar = (slots == null ? void 0 : slots.bar) ?? BarElementPath;
  const barProps = useSlotProps_default({
    elementType: Bar,
    externalSlotProps: slotProps == null ? void 0 : slotProps.bar,
    externalForwardedProps: other,
    additionalProps: _extends({}, getInteractionItemProps({
      type: "bar",
      seriesId: id,
      dataIndex
    }), {
      style,
      onClick,
      cursor: onClick ? "pointer" : "unset"
    }),
    className: classes.root,
    ownerState
  });
  return (0, import_jsx_runtime10.jsx)(Bar, _extends({}, barProps));
}
true ? BarElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types6.default.object,
  dataIndex: import_prop_types6.default.number.isRequired,
  id: import_prop_types6.default.oneOfType([import_prop_types6.default.number, import_prop_types6.default.string]).isRequired,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types6.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types6.default.object
} : void 0;

// node_modules/@mui/x-charts/BarChart/BarClipPath.js
var React11 = __toESM(require_react());

// node_modules/@mui/x-charts/BarChart/getRadius.js
var getRadius = (corner, {
  hasNegative,
  hasPositive,
  borderRadius,
  layout
}) => {
  if (!borderRadius) {
    return 0;
  }
  const isVertical = layout === "vertical";
  if (corner === "top-left" && (isVertical && hasPositive || !isVertical && hasNegative)) {
    return borderRadius;
  }
  if (corner === "top-right" && (isVertical && hasPositive || !isVertical && hasPositive)) {
    return borderRadius;
  }
  if (corner === "bottom-right" && (isVertical && hasNegative || !isVertical && hasPositive)) {
    return borderRadius;
  }
  if (corner === "bottom-left" && (isVertical && hasNegative || !isVertical && hasNegative)) {
    return borderRadius;
  }
  return 0;
};

// node_modules/@mui/x-charts/BarChart/BarClipPath.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var _excluded3 = ["style", "maskId"];
var buildInset = (corners) => `inset(0px round ${corners.topLeft}px ${corners.topRight}px ${corners.bottomRight}px ${corners.bottomLeft}px)`;
function BarClipRect(props) {
  var _a, _b;
  const radiusData = props.ownerState;
  return (0, import_jsx_runtime11.jsx)(animated.rect, {
    style: _extends({}, props.style, {
      clipPath: (props.ownerState.layout === "vertical" ? (_a = props.style) == null ? void 0 : _a.height : (_b = props.style) == null ? void 0 : _b.width).to((value) => buildInset({
        topLeft: Math.min(value, getRadius("top-left", radiusData)),
        topRight: Math.min(value, getRadius("top-right", radiusData)),
        bottomRight: Math.min(value, getRadius("bottom-right", radiusData)),
        bottomLeft: Math.min(value, getRadius("bottom-left", radiusData))
      }))
    })
  });
}
function BarClipPath(props) {
  const {
    style,
    maskId
  } = props, rest = _objectWithoutPropertiesLoose(props, _excluded3);
  if (!props.borderRadius || props.borderRadius <= 0) {
    return null;
  }
  return (0, import_jsx_runtime11.jsx)("clipPath", {
    id: maskId,
    children: (0, import_jsx_runtime11.jsx)(BarClipRect, {
      ownerState: rest,
      style
    })
  });
}

// node_modules/@mui/x-charts/BarChart/BarLabel/BarLabelPlot.js
var React14 = __toESM(require_react());

// node_modules/@mui/x-charts/BarChart/BarLabel/BarLabelItem.js
var React13 = __toESM(require_react());
var import_prop_types8 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/BarChart/BarLabel/barLabelClasses.js
function getBarLabelUtilityClass(slot) {
  return generateUtilityClass("MuiBarLabel", slot);
}
var barLabelClasses = generateUtilityClasses("MuiBarLabel", ["root", "highlighted", "faded"]);
var useUtilityClasses3 = (ownerState) => {
  const {
    classes,
    seriesId,
    isFaded,
    isHighlighted
  } = ownerState;
  const slots = {
    root: ["root", `series-${seriesId}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getBarLabelUtilityClass, classes);
};

// node_modules/@mui/x-charts/BarChart/BarLabel/getBarLabel.js
var getBarLabel = (options) => {
  const {
    barLabel,
    value,
    dataIndex,
    seriesId,
    height,
    width
  } = options;
  if (barLabel === "value") {
    return value ? value == null ? void 0 : value.toString() : null;
  }
  return barLabel({
    seriesId,
    dataIndex,
    value
  }, {
    bar: {
      height,
      width
    }
  });
};

// node_modules/@mui/x-charts/BarChart/BarLabel/BarLabel.js
var React12 = __toESM(require_react());
var import_prop_types7 = __toESM(require_prop_types());
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var _excluded4 = ["seriesId", "dataIndex", "color", "isFaded", "isHighlighted", "classes"];
var BarLabelComponent = styled_default(animated.text, {
  name: "MuiBarLabel",
  slot: "Root",
  overridesResolver: (_, styles) => [{
    [`&.${barLabelClasses.faded}`]: styles.faded
  }, {
    [`&.${barLabelClasses.highlighted}`]: styles.highlighted
  }, styles.root]
})(({
  theme
}) => {
  var _a, _b, _c, _d;
  return _extends({}, (_a = theme == null ? void 0 : theme.typography) == null ? void 0 : _a.body2, {
    stroke: "none",
    fill: (_d = (_c = (_b = theme.vars || theme) == null ? void 0 : _b.palette) == null ? void 0 : _c.text) == null ? void 0 : _d.primary,
    transition: "opacity 0.2s ease-in, fill 0.2s ease-in",
    textAnchor: "middle",
    dominantBaseline: "central",
    pointerEvents: "none",
    opacity: 1,
    [`&.${barLabelClasses.faded}`]: {
      opacity: 0.3
    }
  });
});
function BarLabel(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiBarLabel"
  });
  const otherProps = _objectWithoutPropertiesLoose(props, _excluded4);
  return (0, import_jsx_runtime12.jsx)(BarLabelComponent, _extends({}, otherProps));
}
true ? BarLabel.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types7.default.object,
  dataIndex: import_prop_types7.default.number.isRequired,
  isFaded: import_prop_types7.default.bool.isRequired,
  isHighlighted: import_prop_types7.default.bool.isRequired,
  seriesId: import_prop_types7.default.oneOfType([import_prop_types7.default.number, import_prop_types7.default.string]).isRequired
} : void 0;

// node_modules/@mui/x-charts/BarChart/BarLabel/BarLabelItem.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var _excluded5 = ["seriesId", "classes", "color", "style", "dataIndex", "barLabel", "slots", "slotProps", "height", "width", "value"];
var _excluded22 = ["ownerState"];
function BarLabelItem(props) {
  const {
    seriesId,
    classes: innerClasses,
    color: color2,
    style,
    dataIndex,
    barLabel,
    slots,
    slotProps,
    height,
    width,
    value
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId,
    dataIndex
  });
  const ownerState = {
    seriesId,
    classes: innerClasses,
    color: color2,
    isFaded,
    isHighlighted,
    dataIndex
  };
  const classes = useUtilityClasses3(ownerState);
  const Component = (slots == null ? void 0 : slots.barLabel) ?? BarLabel;
  const _useSlotProps = useSlotProps_default({
    elementType: Component,
    externalSlotProps: slotProps == null ? void 0 : slotProps.barLabel,
    additionalProps: _extends({}, other, {
      style,
      className: classes.root
    }),
    ownerState
  }), {
    ownerState: barLabelOwnerState
  } = _useSlotProps, barLabelProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded22);
  if (!barLabel) {
    return null;
  }
  const formattedLabelText = getBarLabel({
    barLabel,
    value,
    dataIndex,
    seriesId,
    height,
    width
  });
  if (!formattedLabelText) {
    return null;
  }
  return (0, import_jsx_runtime13.jsx)(Component, _extends({}, barLabelProps, barLabelOwnerState, {
    children: formattedLabelText
  }));
}
true ? BarLabelItem.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If provided, the function will be used to format the label of the bar.
   * It can be set to 'value' to display the current value.
   * @param {BarItem} item The item to format.
   * @param {BarLabelContext} context data about the bar.
   * @returns {string} The formatted label.
   */
  barLabel: import_prop_types8.default.oneOfType([import_prop_types8.default.oneOf(["value"]), import_prop_types8.default.func]),
  classes: import_prop_types8.default.object,
  color: import_prop_types8.default.string.isRequired,
  dataIndex: import_prop_types8.default.number.isRequired,
  /**
   * The height of the bar.
   */
  height: import_prop_types8.default.number.isRequired,
  seriesId: import_prop_types8.default.oneOfType([import_prop_types8.default.number, import_prop_types8.default.string]).isRequired,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types8.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types8.default.object,
  /**
   * The value of the data point.
   */
  value: import_prop_types8.default.number,
  /**
   * The width of the bar.
   */
  width: import_prop_types8.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/BarChart/BarLabel/BarLabelPlot.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var _excluded6 = ["bars", "skipAnimation"];
var leaveStyle = ({
  layout,
  yOrigin,
  x,
  width,
  y,
  xOrigin,
  height
}) => _extends({}, layout === "vertical" ? {
  y: yOrigin,
  x: x + width / 2,
  height: 0,
  width
} : {
  y: y + height / 2,
  x: xOrigin,
  height,
  width: 0
});
var enterStyle = ({
  x,
  width,
  y,
  height
}) => ({
  x: x + width / 2,
  y: y + height / 2,
  height,
  width
});
function BarLabelPlot(props) {
  const {
    bars,
    skipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded6);
  const barLabelTransition = useTransition(bars, {
    keys: (bar) => `${bar.seriesId}-${bar.dataIndex}`,
    from: leaveStyle,
    leave: null,
    enter: enterStyle,
    update: enterStyle,
    immediate: skipAnimation
  });
  return (0, import_jsx_runtime14.jsx)(React14.Fragment, {
    children: barLabelTransition((style, {
      seriesId,
      dataIndex,
      color: color2,
      value,
      width,
      height
    }) => (0, import_jsx_runtime14.jsx)(BarLabelItem, _extends({
      seriesId,
      dataIndex,
      value,
      color: color2,
      width,
      height
    }, other, {
      style
    })))
  });
}

// node_modules/@mui/x-charts/BarChart/checkScaleErrors.js
var getAxisMessage = (axisDirection, axisId) => {
  const axisName = `${axisDirection}-axis`;
  const axisIdName = `${axisDirection}Axis`;
  const axisDefaultKey = axisDirection === "x" ? DEFAULT_X_AXIS_KEY : DEFAULT_Y_AXIS_KEY;
  return axisId === axisDefaultKey ? `The first \`${axisIdName}\`` : `The ${axisName} with id "${axisId}"`;
};
function checkScaleErrors(verticalLayout, seriesId, xAxisId, xAxis, yAxisId, yAxis) {
  const xAxisConfig = xAxis[xAxisId];
  const yAxisConfig = yAxis[yAxisId];
  const discreteAxisConfig = verticalLayout ? xAxisConfig : yAxisConfig;
  const continuousAxisConfig = verticalLayout ? yAxisConfig : xAxisConfig;
  const discreteAxisId = verticalLayout ? xAxisId : yAxisId;
  const continuousAxisId = verticalLayout ? yAxisId : xAxisId;
  const discreteAxisDirection = verticalLayout ? "x" : "y";
  const continuousAxisDirection = verticalLayout ? "y" : "x";
  if (!isBandScaleConfig(discreteAxisConfig)) {
    throw new Error(`MUI X: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} should be of type "band" to display the bar series of id "${seriesId}".`);
  }
  if (discreteAxisConfig.data === void 0) {
    throw new Error(`MUI X: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} should have data property.`);
  }
  if (isBandScaleConfig(continuousAxisConfig) || isPointScaleConfig(continuousAxisConfig)) {
    throw new Error(`MUI X: ${getAxisMessage(continuousAxisDirection, continuousAxisId)} should be a continuous type to display the bar series of id "${seriesId}".`);
  }
}

// node_modules/@mui/x-charts/BarChart/BarPlot.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var _excluded7 = ["skipAnimation", "onItemClick", "borderRadius", "barLabel"];
function getBandSize({
  bandWidth: W,
  numberOfGroups: N,
  gapRatio: r
}) {
  if (r === 0) {
    return {
      barWidth: W / N,
      offset: 0
    };
  }
  const barWidth = W / (N + (N - 1) * r);
  const offset = r * barWidth;
  return {
    barWidth,
    offset
  };
}
var useAggregatedData = () => {
  const seriesData = useBarSeries() ?? {
    series: {},
    stackingGroups: [],
    seriesOrder: []
  };
  const axisData = useCartesianContext();
  const chartId = useChartId();
  const {
    series,
    stackingGroups
  } = seriesData;
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = axisData;
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  const masks = {};
  const data = stackingGroups.flatMap(({
    ids: groupIds
  }, groupIndex) => {
    return groupIds.flatMap((seriesId) => {
      const xAxisId = series[seriesId].xAxisId ?? series[seriesId].xAxisKey ?? defaultXAxisId;
      const yAxisId = series[seriesId].yAxisId ?? series[seriesId].yAxisKey ?? defaultYAxisId;
      const xAxisConfig = xAxis[xAxisId];
      const yAxisConfig = yAxis[yAxisId];
      const verticalLayout = series[seriesId].layout === "vertical";
      checkScaleErrors(verticalLayout, seriesId, xAxisId, xAxis, yAxisId, yAxis);
      const baseScaleConfig = verticalLayout ? xAxisConfig : yAxisConfig;
      const xScale = xAxisConfig.scale;
      const yScale = yAxisConfig.scale;
      const colorGetter = getColor_default(series[seriesId], xAxis[xAxisId], yAxis[yAxisId]);
      const bandWidth = baseScaleConfig.scale.bandwidth();
      const {
        barWidth,
        offset
      } = getBandSize({
        bandWidth,
        numberOfGroups: stackingGroups.length,
        gapRatio: baseScaleConfig.barGapRatio
      });
      const barOffset = groupIndex * (barWidth + offset);
      const {
        stackedData
      } = series[seriesId];
      return stackedData.map((values, dataIndex) => {
        var _a, _b;
        const valueCoordinates = values.map((v) => verticalLayout ? yScale(v) : xScale(v));
        const minValueCoord = Math.round(Math.min(...valueCoordinates));
        const maxValueCoord = Math.round(Math.max(...valueCoordinates));
        const stackId = series[seriesId].stack;
        const result = {
          seriesId,
          dataIndex,
          layout: series[seriesId].layout,
          x: verticalLayout ? xScale((_a = xAxis[xAxisId].data) == null ? void 0 : _a[dataIndex]) + barOffset : minValueCoord,
          y: verticalLayout ? minValueCoord : yScale((_b = yAxis[yAxisId].data) == null ? void 0 : _b[dataIndex]) + barOffset,
          xOrigin: xScale(0),
          yOrigin: yScale(0),
          height: verticalLayout ? maxValueCoord - minValueCoord : barWidth,
          width: verticalLayout ? barWidth : maxValueCoord - minValueCoord,
          color: colorGetter(dataIndex),
          value: series[seriesId].data[dataIndex],
          maskId: `${chartId}_${stackId || seriesId}_${groupIndex}_${dataIndex}`
        };
        if (!masks[result.maskId]) {
          masks[result.maskId] = {
            id: result.maskId,
            width: 0,
            height: 0,
            hasNegative: false,
            hasPositive: false,
            layout: result.layout,
            xOrigin: xScale(0),
            yOrigin: yScale(0),
            x: 0,
            y: 0
          };
        }
        const mask = masks[result.maskId];
        mask.width = result.layout === "vertical" ? result.width : mask.width + result.width;
        mask.height = result.layout === "vertical" ? mask.height + result.height : result.height;
        mask.x = Math.min(mask.x === 0 ? Infinity : mask.x, result.x);
        mask.y = Math.min(mask.y === 0 ? Infinity : mask.y, result.y);
        mask.hasNegative = mask.hasNegative || (result.value ?? 0) < 0;
        mask.hasPositive = mask.hasPositive || (result.value ?? 0) > 0;
        return result;
      });
    });
  });
  return {
    completedData: data,
    masksData: Object.values(masks)
  };
};
var leaveStyle2 = ({
  layout,
  yOrigin,
  x,
  width,
  y,
  xOrigin,
  height
}) => _extends({}, layout === "vertical" ? {
  y: yOrigin,
  x,
  height: 0,
  width
} : {
  y,
  x: xOrigin,
  height,
  width: 0
});
var enterStyle2 = ({
  x,
  width,
  y,
  height
}) => ({
  y,
  x,
  height,
  width
});
function BarPlot(props) {
  const {
    completedData,
    masksData
  } = useAggregatedData();
  const {
    skipAnimation: inSkipAnimation,
    onItemClick,
    borderRadius,
    barLabel
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded7);
  const skipAnimation = useSkipAnimation(inSkipAnimation);
  const withoutBorderRadius = !borderRadius || borderRadius <= 0;
  const transition = useTransition(completedData, {
    keys: (bar) => `${bar.seriesId}-${bar.dataIndex}`,
    from: leaveStyle2,
    leave: leaveStyle2,
    enter: enterStyle2,
    update: enterStyle2,
    immediate: skipAnimation
  });
  const maskTransition = useTransition(withoutBorderRadius ? [] : masksData, {
    keys: (v) => v.id,
    from: leaveStyle2,
    leave: leaveStyle2,
    enter: enterStyle2,
    update: enterStyle2,
    immediate: skipAnimation
  });
  return (0, import_jsx_runtime15.jsxs)(React15.Fragment, {
    children: [!withoutBorderRadius && maskTransition((style, {
      id,
      hasPositive,
      hasNegative,
      layout
    }) => {
      return (0, import_jsx_runtime15.jsx)(BarClipPath, {
        maskId: id,
        borderRadius,
        hasNegative,
        hasPositive,
        layout,
        style
      });
    }), transition((style, {
      seriesId,
      dataIndex,
      color: color2,
      maskId
    }) => {
      const barElement = (0, import_jsx_runtime15.jsx)(BarElement, _extends({
        id: seriesId,
        dataIndex,
        color: color2
      }, other, {
        onClick: onItemClick && ((event) => {
          onItemClick(event, {
            type: "bar",
            seriesId,
            dataIndex
          });
        }),
        style
      }));
      if (withoutBorderRadius) {
        return barElement;
      }
      return (0, import_jsx_runtime15.jsx)("g", {
        clipPath: `url(#${maskId})`,
        children: barElement
      });
    }), barLabel && (0, import_jsx_runtime15.jsx)(BarLabelPlot, _extends({
      bars: completedData,
      skipAnimation,
      barLabel
    }, other))]
  });
}
true ? BarPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If provided, the function will be used to format the label of the bar.
   * It can be set to 'value' to display the current value.
   * @param {BarItem} item The item to format.
   * @param {BarLabelContext} context data about the bar.
   * @returns {string} The formatted label.
   */
  barLabel: import_prop_types9.default.oneOfType([import_prop_types9.default.oneOf(["value"]), import_prop_types9.default.func]),
  /**
   * Defines the border radius of the bar element.
   */
  borderRadius: import_prop_types9.default.number,
  /**
   * Callback fired when a bar item is clicked.
   * @param {React.MouseEvent<SVGElement, MouseEvent>} event The event source of the callback.
   * @param {BarItemIdentifier} barItemIdentifier The bar item identifier.
   */
  onItemClick: import_prop_types9.default.func,
  /**
   * If `true`, animations are skipped.
   * @default undefined
   */
  skipAnimation: import_prop_types9.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types9.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types9.default.object
} : void 0;

// node_modules/@mui/x-charts/BarChart/useBarChartProps.js
var _excluded8 = ["xAxis", "yAxis", "series", "width", "height", "margin", "colors", "dataset", "sx", "tooltip", "onAxisClick", "axisHighlight", "legend", "grid", "topAxis", "leftAxis", "rightAxis", "bottomAxis", "children", "slots", "slotProps", "skipAnimation", "loading", "layout", "onItemClick", "highlightedItem", "onHighlightChange", "borderRadius", "barLabel", "className"];
var useBarChartProps = (props) => {
  const {
    xAxis,
    yAxis,
    series,
    width,
    height,
    margin,
    colors,
    dataset,
    sx,
    tooltip,
    onAxisClick,
    axisHighlight,
    legend,
    grid,
    topAxis,
    leftAxis,
    rightAxis,
    bottomAxis,
    children,
    slots,
    slotProps,
    skipAnimation,
    loading,
    layout,
    onItemClick,
    highlightedItem,
    onHighlightChange,
    borderRadius,
    barLabel,
    className
  } = props, rest = _objectWithoutPropertiesLoose(props, _excluded8);
  const id = useId();
  const clipPathId = `${id}-clip-path`;
  const hasHorizontalSeries = layout === "horizontal" || layout === void 0 && series.some((item) => item.layout === "horizontal");
  const defaultAxisConfig = {
    scaleType: "band",
    data: Array.from({
      length: Math.max(...series.map((s) => (s.data ?? dataset ?? []).length))
    }, (_, index) => index)
  };
  const chartContainerProps = _extends({}, rest, {
    series: series.map((s) => _extends({
      type: "bar"
    }, s, {
      layout: hasHorizontalSeries ? "horizontal" : "vertical"
    })),
    width,
    height,
    margin,
    colors,
    dataset,
    xAxis: xAxis ?? (hasHorizontalSeries ? void 0 : [_extends({
      id: DEFAULT_X_AXIS_KEY
    }, defaultAxisConfig)]),
    yAxis: yAxis ?? (hasHorizontalSeries ? [_extends({
      id: DEFAULT_Y_AXIS_KEY
    }, defaultAxisConfig)] : void 0),
    sx,
    highlightedItem,
    onHighlightChange,
    disableAxisListener: (tooltip == null ? void 0 : tooltip.trigger) !== "axis" && (axisHighlight == null ? void 0 : axisHighlight.x) === "none" && (axisHighlight == null ? void 0 : axisHighlight.y) === "none" && !onAxisClick,
    className,
    skipAnimation
  });
  const barPlotProps = {
    onItemClick,
    slots,
    slotProps,
    borderRadius,
    barLabel
  };
  const axisClickHandlerProps = {
    onAxisClick
  };
  const gridProps = {
    vertical: grid == null ? void 0 : grid.vertical,
    horizontal: grid == null ? void 0 : grid.horizontal
  };
  const clipPathGroupProps = {
    clipPath: `url(#${clipPathId})`
  };
  const clipPathProps = {
    id: clipPathId
  };
  const overlayProps = {
    slots,
    slotProps,
    loading
  };
  const chartsAxisProps = {
    topAxis,
    leftAxis,
    rightAxis,
    bottomAxis,
    slots,
    slotProps
  };
  const axisHighlightProps = _extends({}, hasHorizontalSeries ? {
    y: "band"
  } : {
    x: "band"
  }, axisHighlight);
  const legendProps = _extends({}, legend, {
    slots,
    slotProps
  });
  const tooltipProps = _extends({}, tooltip, {
    slots,
    slotProps
  });
  return {
    chartContainerProps,
    barPlotProps,
    axisClickHandlerProps,
    gridProps,
    clipPathProps,
    clipPathGroupProps,
    overlayProps,
    chartsAxisProps,
    axisHighlightProps,
    legendProps,
    tooltipProps,
    children
  };
};

// node_modules/@mui/x-charts/BarChart/BarChart.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var BarChart = React16.forwardRef(function BarChart2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiBarChart"
  });
  const {
    chartContainerProps,
    barPlotProps,
    axisClickHandlerProps,
    gridProps,
    clipPathProps,
    clipPathGroupProps,
    overlayProps,
    chartsAxisProps,
    axisHighlightProps,
    legendProps,
    tooltipProps,
    children
  } = useBarChartProps(props);
  return (0, import_jsx_runtime16.jsxs)(ResponsiveChartContainer, _extends({
    ref
  }, chartContainerProps, {
    children: [props.onAxisClick && (0, import_jsx_runtime16.jsx)(ChartsOnAxisClickHandler, _extends({}, axisClickHandlerProps)), (0, import_jsx_runtime16.jsx)(ChartsGrid, _extends({}, gridProps)), (0, import_jsx_runtime16.jsxs)("g", _extends({}, clipPathGroupProps, {
      children: [(0, import_jsx_runtime16.jsx)(BarPlot, _extends({}, barPlotProps)), (0, import_jsx_runtime16.jsx)(ChartsOverlay, _extends({}, overlayProps)), (0, import_jsx_runtime16.jsx)(ChartsAxisHighlight, _extends({}, axisHighlightProps))]
    })), (0, import_jsx_runtime16.jsx)(ChartsAxis, _extends({}, chartsAxisProps)), (0, import_jsx_runtime16.jsx)(ChartsLegend, _extends({}, legendProps)), !props.loading && (0, import_jsx_runtime16.jsx)(ChartsTooltip, _extends({}, tooltipProps)), (0, import_jsx_runtime16.jsx)(ChartsClipPath, _extends({}, clipPathProps)), children]
  }));
});
true ? BarChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The configuration of axes highlight.
   * Default is set to 'band' in the bar direction.
   * Depends on `layout` prop.
   * @see See {@link https://mui.com/x/react-charts/highlighting highlighting docs} for more details.
   */
  axisHighlight: import_prop_types10.default.shape({
    x: import_prop_types10.default.oneOf(["band", "line", "none"]),
    y: import_prop_types10.default.oneOf(["band", "line", "none"])
  }),
  /**
   * If provided, the function will be used to format the label of the bar.
   * It can be set to 'value' to display the current value.
   * @param {BarItem} item The item to format.
   * @param {BarLabelContext} context data about the bar.
   * @returns {string} The formatted label.
   */
  barLabel: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(["value"]), import_prop_types10.default.func]),
  /**
   * Defines the border radius of the bar element.
   */
  borderRadius: import_prop_types10.default.number,
  /**
   * Indicate which axis to display the bottom of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default xAxisIds[0] The id of the first provided axis
   */
  bottomAxis: import_prop_types10.default.oneOfType([import_prop_types10.default.object, import_prop_types10.default.string]),
  children: import_prop_types10.default.node,
  className: import_prop_types10.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types10.default.oneOfType([import_prop_types10.default.arrayOf(import_prop_types10.default.string), import_prop_types10.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types10.default.arrayOf(import_prop_types10.default.object),
  desc: import_prop_types10.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types10.default.bool,
  /**
   * Option to display a cartesian grid in the background.
   */
  grid: import_prop_types10.default.shape({
    horizontal: import_prop_types10.default.bool,
    vertical: import_prop_types10.default.bool
  }),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types10.default.number,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types10.default.shape({
    dataIndex: import_prop_types10.default.number,
    seriesId: import_prop_types10.default.oneOfType([import_prop_types10.default.number, import_prop_types10.default.string])
  }),
  /**
   * The direction of the bar elements.
   * @default 'vertical'
   */
  layout: import_prop_types10.default.oneOf(["horizontal", "vertical"]),
  /**
   * Indicate which axis to display the left of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default yAxisIds[0] The id of the first provided axis
   */
  leftAxis: import_prop_types10.default.oneOfType([import_prop_types10.default.object, import_prop_types10.default.string]),
  /**
   * @deprecated Consider using `slotProps.legend` instead.
   */
  legend: import_prop_types10.default.shape({
    classes: import_prop_types10.default.object,
    direction: import_prop_types10.default.oneOf(["column", "row"]),
    hidden: import_prop_types10.default.bool,
    itemGap: import_prop_types10.default.number,
    itemMarkHeight: import_prop_types10.default.number,
    itemMarkWidth: import_prop_types10.default.number,
    labelStyle: import_prop_types10.default.object,
    markGap: import_prop_types10.default.number,
    onItemClick: import_prop_types10.default.func,
    padding: import_prop_types10.default.oneOfType([import_prop_types10.default.number, import_prop_types10.default.shape({
      bottom: import_prop_types10.default.number,
      left: import_prop_types10.default.number,
      right: import_prop_types10.default.number,
      top: import_prop_types10.default.number
    })]),
    position: import_prop_types10.default.shape({
      horizontal: import_prop_types10.default.oneOf(["left", "middle", "right"]).isRequired,
      vertical: import_prop_types10.default.oneOf(["bottom", "middle", "top"]).isRequired
    }),
    slotProps: import_prop_types10.default.object,
    slots: import_prop_types10.default.object
  }),
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types10.default.bool,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types10.default.shape({
    bottom: import_prop_types10.default.number,
    left: import_prop_types10.default.number,
    right: import_prop_types10.default.number,
    top: import_prop_types10.default.number
  }),
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | AxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types10.default.func,
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types10.default.func,
  /**
   * Callback fired when a bar item is clicked.
   * @param {React.MouseEvent<SVGElement, MouseEvent>} event The event source of the callback.
   * @param {BarItemIdentifier} barItemIdentifier The bar item identifier.
   */
  onItemClick: import_prop_types10.default.func,
  /**
   * The chart will try to wait for the parent container to resolve its size
   * before it renders for the first time.
   *
   * This can be useful in some scenarios where the chart appear to grow after
   * the first render, like when used inside a grid.
   *
   * @default false
   */
  resolveSizeBeforeRender: import_prop_types10.default.bool,
  /**
   * Indicate which axis to display the right of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default null
   */
  rightAxis: import_prop_types10.default.oneOfType([import_prop_types10.default.object, import_prop_types10.default.string]),
  /**
   * The series to display in the bar chart.
   * An array of [[BarSeriesType]] objects.
   */
  series: import_prop_types10.default.arrayOf(import_prop_types10.default.object).isRequired,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types10.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types10.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types10.default.object,
  sx: import_prop_types10.default.oneOfType([import_prop_types10.default.arrayOf(import_prop_types10.default.oneOfType([import_prop_types10.default.func, import_prop_types10.default.object, import_prop_types10.default.bool])), import_prop_types10.default.func, import_prop_types10.default.object]),
  title: import_prop_types10.default.string,
  /**
   * The configuration of the tooltip.
   * @see See {@link https://mui.com/x/react-charts/tooltip/ tooltip docs} for more details.
   */
  tooltip: import_prop_types10.default.shape({
    axisContent: import_prop_types10.default.elementType,
    classes: import_prop_types10.default.object,
    itemContent: import_prop_types10.default.elementType,
    slotProps: import_prop_types10.default.object,
    slots: import_prop_types10.default.object,
    trigger: import_prop_types10.default.oneOf(["axis", "item", "none"])
  }),
  /**
   * Indicate which axis to display the top of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default null
   */
  topAxis: import_prop_types10.default.oneOfType([import_prop_types10.default.object, import_prop_types10.default.string]),
  viewBox: import_prop_types10.default.shape({
    height: import_prop_types10.default.number,
    width: import_prop_types10.default.number,
    x: import_prop_types10.default.number,
    y: import_prop_types10.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types10.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types10.default.arrayOf(import_prop_types10.default.shape({
    classes: import_prop_types10.default.object,
    colorMap: import_prop_types10.default.oneOfType([import_prop_types10.default.shape({
      colors: import_prop_types10.default.arrayOf(import_prop_types10.default.string).isRequired,
      type: import_prop_types10.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types10.default.string,
      values: import_prop_types10.default.arrayOf(import_prop_types10.default.oneOfType([import_prop_types10.default.instanceOf(Date), import_prop_types10.default.number, import_prop_types10.default.string]).isRequired)
    }), import_prop_types10.default.shape({
      color: import_prop_types10.default.oneOfType([import_prop_types10.default.arrayOf(import_prop_types10.default.string.isRequired), import_prop_types10.default.func]).isRequired,
      max: import_prop_types10.default.oneOfType([import_prop_types10.default.instanceOf(Date), import_prop_types10.default.number]),
      min: import_prop_types10.default.oneOfType([import_prop_types10.default.instanceOf(Date), import_prop_types10.default.number]),
      type: import_prop_types10.default.oneOf(["continuous"]).isRequired
    }), import_prop_types10.default.shape({
      colors: import_prop_types10.default.arrayOf(import_prop_types10.default.string).isRequired,
      thresholds: import_prop_types10.default.arrayOf(import_prop_types10.default.oneOfType([import_prop_types10.default.instanceOf(Date), import_prop_types10.default.number]).isRequired).isRequired,
      type: import_prop_types10.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types10.default.array,
    dataKey: import_prop_types10.default.string,
    disableLine: import_prop_types10.default.bool,
    disableTicks: import_prop_types10.default.bool,
    domainLimit: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(["nice", "strict"]), import_prop_types10.default.func]),
    fill: import_prop_types10.default.string,
    hideTooltip: import_prop_types10.default.bool,
    id: import_prop_types10.default.oneOfType([import_prop_types10.default.number, import_prop_types10.default.string]),
    label: import_prop_types10.default.string,
    labelFontSize: import_prop_types10.default.number,
    labelStyle: import_prop_types10.default.object,
    max: import_prop_types10.default.oneOfType([import_prop_types10.default.instanceOf(Date), import_prop_types10.default.number]),
    min: import_prop_types10.default.oneOfType([import_prop_types10.default.instanceOf(Date), import_prop_types10.default.number]),
    position: import_prop_types10.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types10.default.bool,
    scaleType: import_prop_types10.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types10.default.object,
    slots: import_prop_types10.default.object,
    stroke: import_prop_types10.default.string,
    sx: import_prop_types10.default.oneOfType([import_prop_types10.default.arrayOf(import_prop_types10.default.oneOfType([import_prop_types10.default.func, import_prop_types10.default.object, import_prop_types10.default.bool])), import_prop_types10.default.func, import_prop_types10.default.object]),
    tickFontSize: import_prop_types10.default.number,
    tickInterval: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(["auto"]), import_prop_types10.default.array, import_prop_types10.default.func]),
    tickLabelInterval: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(["auto"]), import_prop_types10.default.func]),
    tickLabelPlacement: import_prop_types10.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types10.default.object,
    tickMaxStep: import_prop_types10.default.number,
    tickMinStep: import_prop_types10.default.number,
    tickNumber: import_prop_types10.default.number,
    tickPlacement: import_prop_types10.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types10.default.number,
    valueFormatter: import_prop_types10.default.func
  })),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types10.default.arrayOf(import_prop_types10.default.shape({
    classes: import_prop_types10.default.object,
    colorMap: import_prop_types10.default.oneOfType([import_prop_types10.default.shape({
      colors: import_prop_types10.default.arrayOf(import_prop_types10.default.string).isRequired,
      type: import_prop_types10.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types10.default.string,
      values: import_prop_types10.default.arrayOf(import_prop_types10.default.oneOfType([import_prop_types10.default.instanceOf(Date), import_prop_types10.default.number, import_prop_types10.default.string]).isRequired)
    }), import_prop_types10.default.shape({
      color: import_prop_types10.default.oneOfType([import_prop_types10.default.arrayOf(import_prop_types10.default.string.isRequired), import_prop_types10.default.func]).isRequired,
      max: import_prop_types10.default.oneOfType([import_prop_types10.default.instanceOf(Date), import_prop_types10.default.number]),
      min: import_prop_types10.default.oneOfType([import_prop_types10.default.instanceOf(Date), import_prop_types10.default.number]),
      type: import_prop_types10.default.oneOf(["continuous"]).isRequired
    }), import_prop_types10.default.shape({
      colors: import_prop_types10.default.arrayOf(import_prop_types10.default.string).isRequired,
      thresholds: import_prop_types10.default.arrayOf(import_prop_types10.default.oneOfType([import_prop_types10.default.instanceOf(Date), import_prop_types10.default.number]).isRequired).isRequired,
      type: import_prop_types10.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types10.default.array,
    dataKey: import_prop_types10.default.string,
    disableLine: import_prop_types10.default.bool,
    disableTicks: import_prop_types10.default.bool,
    domainLimit: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(["nice", "strict"]), import_prop_types10.default.func]),
    fill: import_prop_types10.default.string,
    hideTooltip: import_prop_types10.default.bool,
    id: import_prop_types10.default.oneOfType([import_prop_types10.default.number, import_prop_types10.default.string]),
    label: import_prop_types10.default.string,
    labelFontSize: import_prop_types10.default.number,
    labelStyle: import_prop_types10.default.object,
    max: import_prop_types10.default.oneOfType([import_prop_types10.default.instanceOf(Date), import_prop_types10.default.number]),
    min: import_prop_types10.default.oneOfType([import_prop_types10.default.instanceOf(Date), import_prop_types10.default.number]),
    position: import_prop_types10.default.oneOf(["left", "right"]),
    reverse: import_prop_types10.default.bool,
    scaleType: import_prop_types10.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types10.default.object,
    slots: import_prop_types10.default.object,
    stroke: import_prop_types10.default.string,
    sx: import_prop_types10.default.oneOfType([import_prop_types10.default.arrayOf(import_prop_types10.default.oneOfType([import_prop_types10.default.func, import_prop_types10.default.object, import_prop_types10.default.bool])), import_prop_types10.default.func, import_prop_types10.default.object]),
    tickFontSize: import_prop_types10.default.number,
    tickInterval: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(["auto"]), import_prop_types10.default.array, import_prop_types10.default.func]),
    tickLabelInterval: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(["auto"]), import_prop_types10.default.func]),
    tickLabelPlacement: import_prop_types10.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types10.default.object,
    tickMaxStep: import_prop_types10.default.number,
    tickMinStep: import_prop_types10.default.number,
    tickNumber: import_prop_types10.default.number,
    tickPlacement: import_prop_types10.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types10.default.number,
    valueFormatter: import_prop_types10.default.func
  }))
} : void 0;

// node_modules/@mui/x-charts/LineChart/LineChart.js
var React30 = __toESM(require_react());
var import_prop_types22 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/LineChart/AreaPlot.js
var React21 = __toESM(require_react());
var import_prop_types13 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/LineChart/AreaElement.js
var React20 = __toESM(require_react());
var import_prop_types12 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/LineChart/AnimatedArea.js
var React19 = __toESM(require_react());
var import_prop_types11 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/internals/useStringInterpolator.js
var React17 = __toESM(require_react());
function usePrevious(value) {
  const ref = React17.useRef({
    currentPath: value,
    previousPath: void 0
  });
  if (ref.current.currentPath !== value) {
    ref.current = {
      currentPath: value,
      previousPath: ref.current.currentPath
    };
  }
  return ref.current;
}
var useStringInterpolator = (path) => {
  const memoryRef = usePrevious(path);
  const interpolator = React17.useMemo(() => memoryRef.previousPath ? string_default(memoryRef.previousPath, memoryRef.currentPath) : () => memoryRef.currentPath, [memoryRef.currentPath, memoryRef.previousPath]);
  return interpolator;
};

// node_modules/@mui/x-charts/LineChart/AppearingMask.js
var React18 = __toESM(require_react());

// node_modules/@mui/x-charts/internals/cleanId.js
function cleanId(id) {
  return id.replace(" ", "_");
}

// node_modules/@mui/x-charts/LineChart/AppearingMask.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
function AppearingMask(props) {
  const drawingArea = useDrawingArea();
  const chartId = useChartId();
  const transitionAppear = useTransition([drawingArea], {
    from: (v) => ({
      animatedWidth: v.left
    }),
    enter: (v) => ({
      animatedWidth: v.width + v.left + v.right
    }),
    leave: (v) => ({
      animatedWidth: v.width + v.left + v.right
    }),
    reset: false,
    immediate: props.skipAnimation
  });
  const clipId = cleanId(`${chartId}-${props.id}`);
  return (0, import_jsx_runtime17.jsxs)(React18.Fragment, {
    children: [(0, import_jsx_runtime17.jsx)("clipPath", {
      id: clipId,
      children: transitionAppear((style) => (0, import_jsx_runtime17.jsx)(animated.rect, {
        x: 0,
        y: 0,
        width: style.animatedWidth,
        height: drawingArea.top + drawingArea.height + drawingArea.bottom
      }))
    }), (0, import_jsx_runtime17.jsx)("g", {
      clipPath: `url(#${clipId})`,
      children: props.children
    })]
  });
}

// node_modules/@mui/x-charts/LineChart/AnimatedArea.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var _excluded9 = ["d", "skipAnimation", "ownerState"];
var AreaElementPath = styled_default(animated.path, {
  name: "MuiAreaElement",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  ownerState
}) => ({
  stroke: "none",
  fill: ownerState.gradientId && `url(#${ownerState.gradientId})` || ownerState.isHighlighted && color(ownerState.color).brighter(1).formatHex() || color(ownerState.color).brighter(0.5).formatHex(),
  transition: "opacity 0.2s ease-in, fill 0.2s ease-in",
  opacity: ownerState.isFaded ? 0.3 : 1
}));
function AnimatedArea(props) {
  const {
    d,
    skipAnimation,
    ownerState
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded9);
  const stringInterpolator = useStringInterpolator(d);
  const transitionChange = useTransition([stringInterpolator], {
    from: {
      value: 0
    },
    to: {
      value: 1
    },
    enter: {
      value: 1
    },
    reset: false,
    immediate: skipAnimation
  });
  return (0, import_jsx_runtime18.jsx)(AppearingMask, {
    skipAnimation,
    id: `${ownerState.id}-area-clip`,
    children: transitionChange((style, interpolator) => (0, import_jsx_runtime18.jsx)(AreaElementPath, _extends({}, other, {
      ownerState,
      d: style.value.to(interpolator)
    })))
  });
}
true ? AnimatedArea.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  d: import_prop_types11.default.string.isRequired,
  ownerState: import_prop_types11.default.shape({
    classes: import_prop_types11.default.object,
    color: import_prop_types11.default.string.isRequired,
    gradientId: import_prop_types11.default.string,
    id: import_prop_types11.default.oneOfType([import_prop_types11.default.number, import_prop_types11.default.string]).isRequired,
    isFaded: import_prop_types11.default.bool.isRequired,
    isHighlighted: import_prop_types11.default.bool.isRequired
  }).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types11.default.bool
} : void 0;

// node_modules/@mui/x-charts/LineChart/AreaElement.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var _excluded10 = ["id", "classes", "color", "gradientId", "slots", "slotProps", "onClick"];
function getAreaElementUtilityClass(slot) {
  return generateUtilityClass("MuiAreaElement", slot);
}
var areaElementClasses = generateUtilityClasses("MuiAreaElement", ["root", "highlighted", "faded"]);
var useUtilityClasses4 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getAreaElementUtilityClass, classes);
};
function AreaElement(props) {
  const {
    id,
    classes: innerClasses,
    color: color2,
    gradientId,
    slots,
    slotProps,
    onClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded10);
  const getInteractionItemProps = useInteractionItemProps();
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId: id
  });
  const ownerState = {
    id,
    classes: innerClasses,
    color: color2,
    gradientId,
    isFaded,
    isHighlighted
  };
  const classes = useUtilityClasses4(ownerState);
  const Area = (slots == null ? void 0 : slots.area) ?? AnimatedArea;
  const areaProps = useSlotProps_default({
    elementType: Area,
    externalSlotProps: slotProps == null ? void 0 : slotProps.area,
    additionalProps: _extends({}, getInteractionItemProps({
      type: "line",
      seriesId: id
    }), {
      onClick,
      cursor: onClick ? "pointer" : "unset"
    }),
    className: classes.root,
    ownerState
  });
  return (0, import_jsx_runtime19.jsx)(Area, _extends({}, other, areaProps));
}
true ? AreaElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types12.default.object,
  color: import_prop_types12.default.string.isRequired,
  d: import_prop_types12.default.string.isRequired,
  gradientId: import_prop_types12.default.string,
  id: import_prop_types12.default.oneOfType([import_prop_types12.default.number, import_prop_types12.default.string]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types12.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types12.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types12.default.object
} : void 0;

// node_modules/@mui/x-charts/internals/getCurve.js
function getCurveFactory(curveType) {
  switch (curveType) {
    case "catmullRom": {
      return catmullRom_default.alpha(0.5);
    }
    case "linear": {
      return linear_default;
    }
    case "monotoneX": {
      return monotoneX;
    }
    case "monotoneY": {
      return monotoneY;
    }
    case "natural": {
      return natural_default;
    }
    case "step": {
      return step_default;
    }
    case "stepBefore": {
      return stepBefore;
    }
    case "stepAfter": {
      return stepAfter;
    }
    default:
      return monotoneX;
  }
}

// node_modules/@mui/x-charts/LineChart/AreaPlot.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var _excluded11 = ["slots", "slotProps", "onItemClick", "skipAnimation"];
var useAggregatedData2 = () => {
  const seriesData = useLineSeries();
  const axisData = useCartesianContext();
  const allData = React21.useMemo(() => {
    if (seriesData === void 0) {
      return [];
    }
    const {
      series,
      stackingGroups
    } = seriesData;
    const {
      xAxis,
      yAxis,
      xAxisIds,
      yAxisIds
    } = axisData;
    const defaultXAxisId = xAxisIds[0];
    const defaultYAxisId = yAxisIds[0];
    return stackingGroups.flatMap(({
      ids: groupIds
    }) => {
      return [...groupIds].reverse().map((seriesId) => {
        const {
          xAxisId: xAxisIdProp,
          yAxisId: yAxisIdProp,
          xAxisKey = defaultXAxisId,
          yAxisKey = defaultYAxisId,
          stackedData,
          data,
          connectNulls,
          baseline
        } = series[seriesId];
        const xAxisId = xAxisIdProp ?? xAxisKey;
        const yAxisId = yAxisIdProp ?? yAxisKey;
        const xScale = getValueToPositionMapper(xAxis[xAxisId].scale);
        const yScale = yAxis[yAxisId].scale;
        const xData = xAxis[xAxisId].data;
        const gradientUsed = yAxis[yAxisId].colorScale && [yAxisId, "y"] || xAxis[xAxisId].colorScale && [xAxisId, "x"] || void 0;
        if (true) {
          if (xData === void 0) {
            throw new Error(`MUI X: ${xAxisId === DEFAULT_X_AXIS_KEY ? "The first `xAxis`" : `The x-axis with id "${xAxisId}"`} should have data property to be able to display a line plot.`);
          }
          if (xData.length < stackedData.length) {
            throw new Error(`MUI X: The data length of the x axis (${xData.length} items) is lower than the length of series (${stackedData.length} items).`);
          }
        }
        const areaPath = area_default().x((d2) => xScale(d2.x)).defined((_, i) => connectNulls || data[i] != null).y0((d2) => {
          if (typeof baseline === "number") {
            return yScale(baseline);
          }
          if (baseline === "max") {
            return yScale.range()[1];
          }
          if (baseline === "min") {
            return yScale.range()[0];
          }
          const value = d2.y && yScale(d2.y[0]);
          if (Number.isNaN(value)) {
            return yScale.range()[0];
          }
          return value;
        }).y1((d2) => d2.y && yScale(d2.y[1]));
        const curve = getCurveFactory(series[seriesId].curve);
        const formattedData = (xData == null ? void 0 : xData.map((x, index) => ({
          x,
          y: stackedData[index]
        }))) ?? [];
        const d3Data = connectNulls ? formattedData.filter((_, i) => data[i] != null) : formattedData;
        const d = areaPath.curve(curve)(d3Data) || "";
        return _extends({}, series[seriesId], {
          gradientUsed,
          d,
          seriesId
        });
      });
    });
  }, [seriesData, axisData]);
  return allData;
};
function AreaPlot(props) {
  const {
    slots,
    slotProps,
    onItemClick,
    skipAnimation: inSkipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded11);
  const skipAnimation = useSkipAnimation(inSkipAnimation);
  const getGradientId = useChartGradient();
  const completedData = useAggregatedData2();
  return (0, import_jsx_runtime20.jsx)("g", _extends({}, other, {
    children: completedData.map(({
      d,
      seriesId,
      color: color2,
      area,
      gradientUsed
    }) => !!area && (0, import_jsx_runtime20.jsx)(AreaElement, {
      id: seriesId,
      d,
      color: color2,
      gradientId: gradientUsed && getGradientId(...gradientUsed),
      slots,
      slotProps,
      onClick: onItemClick && ((event) => onItemClick(event, {
        type: "line",
        seriesId
      })),
      skipAnimation
    }, seriesId))
  }));
}
true ? AreaPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when a line area item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {LineItemIdentifier} lineItemIdentifier The line item identifier.
   */
  onItemClick: import_prop_types13.default.func,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types13.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types13.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types13.default.object
} : void 0;

// node_modules/@mui/x-charts/LineChart/LinePlot.js
var React24 = __toESM(require_react());
var import_prop_types16 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/LineChart/LineElement.js
var React23 = __toESM(require_react());
var import_prop_types15 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/LineChart/AnimatedLine.js
var React22 = __toESM(require_react());
var import_prop_types14 = __toESM(require_prop_types());
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var _excluded12 = ["d", "skipAnimation", "ownerState"];
var LineElementPath = styled_default(animated.path, {
  name: "MuiLineElement",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  ownerState
}) => ({
  strokeWidth: 2,
  strokeLinejoin: "round",
  fill: "none",
  stroke: ownerState.gradientId && `url(#${ownerState.gradientId})` || ownerState.isHighlighted && color(ownerState.color).brighter(0.5).formatHex() || ownerState.color,
  transition: "opacity 0.2s ease-in, stroke 0.2s ease-in",
  opacity: ownerState.isFaded ? 0.3 : 1
}));
function AnimatedLine(props) {
  const {
    d,
    skipAnimation,
    ownerState
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded12);
  const stringInterpolator = useStringInterpolator(d);
  const transitionChange = useTransition([stringInterpolator], {
    from: {
      value: 0
    },
    to: {
      value: 1
    },
    enter: {
      value: 1
    },
    reset: false,
    immediate: skipAnimation
  });
  return (0, import_jsx_runtime21.jsx)(AppearingMask, {
    skipAnimation,
    id: `${ownerState.id}-line-clip`,
    children: transitionChange((style, interpolator) => (0, import_jsx_runtime21.jsx)(LineElementPath, _extends({}, other, {
      ownerState,
      d: style.value.to(interpolator)
    })))
  });
}
true ? AnimatedLine.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  d: import_prop_types14.default.string.isRequired,
  ownerState: import_prop_types14.default.shape({
    classes: import_prop_types14.default.object,
    color: import_prop_types14.default.string.isRequired,
    gradientId: import_prop_types14.default.string,
    id: import_prop_types14.default.oneOfType([import_prop_types14.default.number, import_prop_types14.default.string]).isRequired,
    isFaded: import_prop_types14.default.bool.isRequired,
    isHighlighted: import_prop_types14.default.bool.isRequired
  }).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types14.default.bool
} : void 0;

// node_modules/@mui/x-charts/LineChart/LineElement.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var _excluded13 = ["id", "classes", "color", "gradientId", "slots", "slotProps", "onClick"];
function getLineElementUtilityClass(slot) {
  return generateUtilityClass("MuiLineElement", slot);
}
var lineElementClasses = generateUtilityClasses("MuiLineElement", ["root", "highlighted", "faded"]);
var useUtilityClasses5 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getLineElementUtilityClass, classes);
};
function LineElement(props) {
  const {
    id,
    classes: innerClasses,
    color: color2,
    gradientId,
    slots,
    slotProps,
    onClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded13);
  const getInteractionItemProps = useInteractionItemProps();
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId: id
  });
  const ownerState = {
    id,
    classes: innerClasses,
    color: color2,
    gradientId,
    isFaded,
    isHighlighted
  };
  const classes = useUtilityClasses5(ownerState);
  const Line = (slots == null ? void 0 : slots.line) ?? AnimatedLine;
  const lineProps = useSlotProps_default({
    elementType: Line,
    externalSlotProps: slotProps == null ? void 0 : slotProps.line,
    additionalProps: _extends({}, getInteractionItemProps({
      type: "line",
      seriesId: id
    }), {
      onClick,
      cursor: onClick ? "pointer" : "unset"
    }),
    className: classes.root,
    ownerState
  });
  return (0, import_jsx_runtime22.jsx)(Line, _extends({}, other, lineProps));
}
true ? LineElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types15.default.object,
  color: import_prop_types15.default.string.isRequired,
  d: import_prop_types15.default.string.isRequired,
  gradientId: import_prop_types15.default.string,
  id: import_prop_types15.default.oneOfType([import_prop_types15.default.number, import_prop_types15.default.string]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types15.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types15.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types15.default.object
} : void 0;

// node_modules/@mui/x-charts/LineChart/LinePlot.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var _excluded14 = ["slots", "slotProps", "skipAnimation", "onItemClick"];
var useAggregatedData3 = () => {
  const seriesData = useLineSeries();
  const axisData = useCartesianContext();
  const allData = React24.useMemo(() => {
    if (seriesData === void 0) {
      return [];
    }
    const {
      series,
      stackingGroups
    } = seriesData;
    const {
      xAxis,
      yAxis,
      xAxisIds,
      yAxisIds
    } = axisData;
    const defaultXAxisId = xAxisIds[0];
    const defaultYAxisId = yAxisIds[0];
    return stackingGroups.flatMap(({
      ids: groupIds
    }) => {
      return groupIds.flatMap((seriesId) => {
        const {
          xAxisId: xAxisIdProp,
          yAxisId: yAxisIdProp,
          xAxisKey = defaultXAxisId,
          yAxisKey = defaultYAxisId,
          stackedData,
          data,
          connectNulls
        } = series[seriesId];
        const xAxisId = xAxisIdProp ?? xAxisKey;
        const yAxisId = yAxisIdProp ?? yAxisKey;
        const xScale = getValueToPositionMapper(xAxis[xAxisId].scale);
        const yScale = yAxis[yAxisId].scale;
        const xData = xAxis[xAxisId].data;
        const gradientUsed = yAxis[yAxisId].colorScale && [yAxisId, "y"] || xAxis[xAxisId].colorScale && [xAxisId, "x"] || void 0;
        if (true) {
          if (xData === void 0) {
            throw new Error(`MUI X: ${xAxisId === DEFAULT_X_AXIS_KEY ? "The first `xAxis`" : `The x-axis with id "${xAxisId}"`} should have data property to be able to display a line plot.`);
          }
          if (xData.length < stackedData.length) {
            throw new Error(`MUI X: The data length of the x axis (${xData.length} items) is lower than the length of series (${stackedData.length} items).`);
          }
        }
        const linePath = line_default().x((d2) => xScale(d2.x)).defined((_, i) => connectNulls || data[i] != null).y((d2) => yScale(d2.y[1]));
        const formattedData = (xData == null ? void 0 : xData.map((x, index) => ({
          x,
          y: stackedData[index]
        }))) ?? [];
        const d3Data = connectNulls ? formattedData.filter((_, i) => data[i] != null) : formattedData;
        const d = linePath.curve(getCurveFactory(series[seriesId].curve))(d3Data) || "";
        return _extends({}, series[seriesId], {
          gradientUsed,
          d,
          seriesId
        });
      });
    });
  }, [seriesData, axisData]);
  return allData;
};
function LinePlot(props) {
  const {
    slots,
    slotProps,
    skipAnimation: inSkipAnimation,
    onItemClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded14);
  const skipAnimation = useSkipAnimation(inSkipAnimation);
  const getGradientId = useChartGradient();
  const completedData = useAggregatedData3();
  return (0, import_jsx_runtime23.jsx)("g", _extends({}, other, {
    children: completedData.map(({
      d,
      seriesId,
      color: color2,
      gradientUsed
    }) => {
      return (0, import_jsx_runtime23.jsx)(LineElement, {
        id: seriesId,
        d,
        color: color2,
        gradientId: gradientUsed && getGradientId(...gradientUsed),
        skipAnimation,
        slots,
        slotProps,
        onClick: onItemClick && ((event) => onItemClick(event, {
          type: "line",
          seriesId
        }))
      }, seriesId);
    })
  }));
}
true ? LinePlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when a line item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {LineItemIdentifier} lineItemIdentifier The line item identifier.
   */
  onItemClick: import_prop_types16.default.func,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types16.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types16.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types16.default.object
} : void 0;

// node_modules/@mui/x-charts/LineChart/MarkPlot.js
var import_prop_types19 = __toESM(require_prop_types());
var React27 = __toESM(require_react());

// node_modules/@mui/x-charts/LineChart/CircleMarkElement.js
var React25 = __toESM(require_react());
var import_prop_types17 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/LineChart/markElementClasses.js
function getMarkElementUtilityClass(slot) {
  return generateUtilityClass("MuiMarkElement", slot);
}
var markElementClasses = generateUtilityClasses("MuiMarkElement", ["root", "highlighted", "faded"]);
var useUtilityClasses6 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getMarkElementUtilityClass, classes);
};

// node_modules/@mui/x-charts/LineChart/CircleMarkElement.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var _excluded15 = ["x", "y", "id", "classes", "color", "dataIndex", "onClick", "skipAnimation", "shape"];
function CircleMarkElement(props) {
  var _a;
  const {
    x,
    y,
    id,
    classes: innerClasses,
    color: color2,
    dataIndex,
    onClick,
    skipAnimation,
    shape
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded15);
  if (shape !== "circle") {
    warnOnce([`MUI X: The mark element of your line chart have shape "${shape}" which is not supported when using \`experimentalRendering=true\`.`, 'Only "circle" are supported with `experimentalRendering`.'].join("\n"), "error");
  }
  const theme = useTheme();
  const getInteractionItemProps = useInteractionItemProps();
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId: id
  });
  const {
    axis
  } = React25.useContext(InteractionContext);
  const position = useSpring({
    to: {
      x,
      y
    },
    immediate: skipAnimation
  });
  const ownerState = {
    id,
    classes: innerClasses,
    isHighlighted: ((_a = axis.x) == null ? void 0 : _a.index) === dataIndex || isHighlighted,
    isFaded,
    color: color2
  };
  const classes = useUtilityClasses6(ownerState);
  return (0, import_jsx_runtime24.jsx)(animated.circle, _extends({}, other, {
    cx: position.x,
    cy: position.y,
    r: 5,
    fill: (theme.vars || theme).palette.background.paper,
    stroke: color2,
    strokeWidth: 2,
    className: classes.root,
    onClick,
    cursor: onClick ? "pointer" : "unset"
  }, getInteractionItemProps({
    type: "line",
    seriesId: id,
    dataIndex
  })));
}
true ? CircleMarkElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types17.default.object,
  /**
   * The index to the element in the series' data array.
   */
  dataIndex: import_prop_types17.default.number.isRequired,
  id: import_prop_types17.default.oneOfType([import_prop_types17.default.number, import_prop_types17.default.string]).isRequired,
  /**
   * The shape of the marker.
   */
  shape: import_prop_types17.default.oneOf(["circle", "cross", "diamond", "square", "star", "triangle", "wye"]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types17.default.bool
} : void 0;

// node_modules/@mui/x-charts/LineChart/MarkElement.js
var React26 = __toESM(require_react());
var import_prop_types18 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/internals/getSymbol.js
function getSymbol(shape) {
  const symbolNames = "circle cross diamond square star triangle wye".split(/ /);
  return symbolNames.indexOf(shape) || 0;
}

// node_modules/@mui/x-charts/LineChart/MarkElement.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var _excluded16 = ["x", "y", "id", "classes", "color", "shape", "dataIndex", "onClick", "skipAnimation"];
var MarkElementPath = styled_default(animated.path, {
  name: "MuiMarkElement",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  ownerState,
  theme
}) => ({
  fill: (theme.vars || theme).palette.background.paper,
  stroke: ownerState.color,
  strokeWidth: 2
}));
function MarkElement(props) {
  var _a;
  const {
    x,
    y,
    id,
    classes: innerClasses,
    color: color2,
    shape,
    dataIndex,
    onClick,
    skipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded16);
  const getInteractionItemProps = useInteractionItemProps();
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId: id
  });
  const {
    axis
  } = React26.useContext(InteractionContext);
  const position = useSpring({
    to: {
      x,
      y
    },
    immediate: skipAnimation
  });
  const ownerState = {
    id,
    classes: innerClasses,
    isHighlighted: ((_a = axis.x) == null ? void 0 : _a.index) === dataIndex || isHighlighted,
    isFaded,
    color: color2
  };
  const classes = useUtilityClasses6(ownerState);
  return (0, import_jsx_runtime25.jsx)(MarkElementPath, _extends({}, other, {
    style: {
      transform: to([position.x, position.y], (pX, pY) => `translate(${pX}px, ${pY}px)`),
      transformOrigin: to([position.x, position.y], (pX, pY) => `${pX}px ${pY}px`)
    },
    ownerState,
    className: classes.root,
    d: Symbol(symbolsFill[getSymbol(shape)])(),
    onClick,
    cursor: onClick ? "pointer" : "unset"
  }, getInteractionItemProps({
    type: "line",
    seriesId: id,
    dataIndex
  })));
}
true ? MarkElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types18.default.object,
  /**
   * The index to the element in the series' data array.
   */
  dataIndex: import_prop_types18.default.number.isRequired,
  id: import_prop_types18.default.oneOfType([import_prop_types18.default.number, import_prop_types18.default.string]).isRequired,
  /**
   * The shape of the marker.
   */
  shape: import_prop_types18.default.oneOf(["circle", "cross", "diamond", "square", "star", "triangle", "wye"]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types18.default.bool
} : void 0;

// node_modules/@mui/x-charts/LineChart/MarkPlot.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
var _excluded17 = ["slots", "slotProps", "skipAnimation", "onItemClick", "experimentalRendering"];
function MarkPlot(props) {
  const {
    slots,
    slotProps,
    skipAnimation: inSkipAnimation,
    onItemClick,
    experimentalRendering
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded17);
  const skipAnimation = useSkipAnimation(inSkipAnimation);
  const seriesData = useLineSeries();
  const axisData = useCartesianContext();
  const chartId = useChartId();
  const drawingArea = useDrawingArea();
  const Mark = (slots == null ? void 0 : slots.mark) ?? (experimentalRendering ? CircleMarkElement : MarkElement);
  if (seriesData === void 0) {
    return null;
  }
  const {
    series,
    stackingGroups
  } = seriesData;
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = axisData;
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  return (0, import_jsx_runtime26.jsx)("g", _extends({}, other, {
    children: stackingGroups.flatMap(({
      ids: groupIds
    }) => {
      return groupIds.map((seriesId) => {
        const {
          xAxisId: xAxisIdProp,
          yAxisId: yAxisIdProp,
          xAxisKey = defaultXAxisId,
          yAxisKey = defaultYAxisId,
          stackedData,
          data,
          showMark = true
        } = series[seriesId];
        if (showMark === false) {
          return null;
        }
        const xAxisId = xAxisIdProp ?? xAxisKey;
        const yAxisId = yAxisIdProp ?? yAxisKey;
        const xScale = getValueToPositionMapper(xAxis[xAxisId].scale);
        const yScale = yAxis[yAxisId].scale;
        const xData = xAxis[xAxisId].data;
        if (xData === void 0) {
          throw new Error(`MUI X: ${xAxisId === DEFAULT_X_AXIS_KEY ? "The first `xAxis`" : `The x-axis with id "${xAxisId}"`} should have data property to be able to display a line plot.`);
        }
        const clipId = cleanId(`${chartId}-${seriesId}-line-clip`);
        const colorGetter = getColor_default3(series[seriesId], xAxis[xAxisId], yAxis[yAxisId]);
        return (0, import_jsx_runtime26.jsx)("g", {
          clipPath: `url(#${clipId})`,
          children: xData == null ? void 0 : xData.map((x, index) => {
            const value = data[index] == null ? null : stackedData[index][1];
            return {
              x: xScale(x),
              y: value === null ? null : yScale(value),
              position: x,
              value,
              index
            };
          }).filter(({
            x,
            y,
            index,
            position,
            value
          }) => {
            if (value === null || y === null) {
              return false;
            }
            if (!drawingArea.isPointInside({
              x,
              y
            })) {
              return false;
            }
            if (showMark === true) {
              return true;
            }
            return showMark({
              x,
              y,
              index,
              position,
              value
            });
          }).map(({
            x,
            y,
            index
          }) => {
            return (0, import_jsx_runtime26.jsx)(Mark, _extends({
              id: seriesId,
              dataIndex: index,
              shape: "circle",
              color: colorGetter(index),
              x,
              y,
              skipAnimation,
              onClick: onItemClick && ((event) => onItemClick(event, {
                type: "line",
                seriesId,
                dataIndex: index
              }))
            }, slotProps == null ? void 0 : slotProps.mark), `${seriesId}-${index}`);
          })
        }, seriesId);
      });
    })
  }));
}
true ? MarkPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true` the mark element will only be able to render circle.
   * Giving fewer customization options, but saving around 40ms per 1.000 marks.
   * @default false
   */
  experimentalRendering: import_prop_types19.default.bool,
  /**
   * Callback fired when a line mark item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {LineItemIdentifier} lineItemIdentifier The line mark item identifier.
   */
  onItemClick: import_prop_types19.default.func,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types19.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types19.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types19.default.object
} : void 0;

// node_modules/@mui/x-charts/LineChart/LineHighlightPlot.js
var React29 = __toESM(require_react());
var import_prop_types21 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/LineChart/LineHighlightElement.js
var React28 = __toESM(require_react());
var import_prop_types20 = __toESM(require_prop_types());
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var _excluded18 = ["x", "y", "id", "classes", "color"];
function getHighlightElementUtilityClass(slot) {
  return generateUtilityClass("MuiHighlightElement", slot);
}
var lineHighlightElementClasses = generateUtilityClasses("MuiHighlightElement", ["root"]);
var useUtilityClasses7 = (ownerState) => {
  const {
    classes,
    id
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`]
  };
  return composeClasses(slots, getHighlightElementUtilityClass, classes);
};
var HighlightElement = styled_default("circle", {
  name: "MuiHighlightElement",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  ownerState
}) => ({
  transform: `translate(${ownerState.x}px, ${ownerState.y}px)`,
  transformOrigin: `${ownerState.x}px ${ownerState.y}px`,
  fill: ownerState.color
}));
function LineHighlightElement(props) {
  const {
    x,
    y,
    id,
    classes: innerClasses,
    color: color2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded18);
  const ownerState = {
    id,
    classes: innerClasses,
    color: color2,
    x,
    y
  };
  const classes = useUtilityClasses7(ownerState);
  return (0, import_jsx_runtime27.jsx)(HighlightElement, _extends({
    pointerEvents: "none",
    ownerState,
    className: classes.root,
    cx: 0,
    cy: 0,
    r: other.r === void 0 ? 5 : other.r
  }, other));
}
true ? LineHighlightElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types20.default.object,
  id: import_prop_types20.default.oneOfType([import_prop_types20.default.number, import_prop_types20.default.string]).isRequired
} : void 0;

// node_modules/@mui/x-charts/LineChart/LineHighlightPlot.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var _excluded19 = ["slots", "slotProps"];
function LineHighlightPlot(props) {
  var _a;
  const {
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded19);
  const seriesData = useLineSeries();
  const axisData = useCartesianContext();
  const drawingArea = useDrawingArea();
  const {
    axis
  } = React29.useContext(InteractionContext);
  const highlightedIndex = (_a = axis.x) == null ? void 0 : _a.index;
  if (highlightedIndex === void 0) {
    return null;
  }
  if (seriesData === void 0) {
    return null;
  }
  const {
    series,
    stackingGroups
  } = seriesData;
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = axisData;
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  const Element = (slots == null ? void 0 : slots.lineHighlight) ?? LineHighlightElement;
  return (0, import_jsx_runtime28.jsx)("g", _extends({}, other, {
    children: stackingGroups.flatMap(({
      ids: groupIds
    }) => {
      return groupIds.flatMap((seriesId) => {
        const {
          xAxisId: xAxisIdProp,
          yAxisId: yAxisIdProp,
          xAxisKey = defaultXAxisId,
          yAxisKey = defaultYAxisId,
          stackedData,
          data,
          disableHighlight
        } = series[seriesId];
        const xAxisId = xAxisIdProp ?? xAxisKey;
        const yAxisId = yAxisIdProp ?? yAxisKey;
        if (disableHighlight || data[highlightedIndex] == null) {
          return null;
        }
        const xScale = getValueToPositionMapper(xAxis[xAxisId].scale);
        const yScale = yAxis[yAxisId].scale;
        const xData = xAxis[xAxisId].data;
        if (xData === void 0) {
          throw new Error(`MUI X: ${xAxisId === DEFAULT_X_AXIS_KEY ? "The first `xAxis`" : `The x-axis with id "${xAxisId}"`} should have data property to be able to display a line plot.`);
        }
        const x = xScale(xData[highlightedIndex]);
        const y = yScale(stackedData[highlightedIndex][1]);
        if (!drawingArea.isPointInside({
          x,
          y
        })) {
          return null;
        }
        const colorGetter = getColor_default3(series[seriesId], xAxis[xAxisId], yAxis[yAxisId]);
        return (0, import_jsx_runtime28.jsx)(Element, _extends({
          id: seriesId,
          color: colorGetter(highlightedIndex),
          x,
          y
        }, slotProps == null ? void 0 : slotProps.lineHighlight), `${seriesId}`);
      });
    })
  }));
}
true ? LineHighlightPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types21.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types21.default.object
} : void 0;

// node_modules/@mui/x-charts/LineChart/useLineChartProps.js
var _excluded20 = ["xAxis", "yAxis", "series", "width", "height", "margin", "colors", "dataset", "sx", "tooltip", "onAxisClick", "onAreaClick", "onLineClick", "onMarkClick", "axisHighlight", "disableLineItemHighlight", "legend", "grid", "topAxis", "leftAxis", "rightAxis", "bottomAxis", "children", "slots", "slotProps", "skipAnimation", "loading", "highlightedItem", "onHighlightChange", "className", "experimentalMarkRendering"];
var useLineChartProps = (props) => {
  const {
    xAxis,
    yAxis,
    series,
    width,
    height,
    margin,
    colors,
    dataset,
    sx,
    tooltip,
    onAxisClick,
    onAreaClick,
    onLineClick,
    onMarkClick,
    axisHighlight,
    disableLineItemHighlight,
    legend,
    grid,
    topAxis,
    leftAxis,
    rightAxis,
    bottomAxis,
    children,
    slots,
    slotProps,
    skipAnimation,
    loading,
    highlightedItem,
    onHighlightChange,
    className,
    experimentalMarkRendering
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded20);
  const id = useId();
  const clipPathId = `${id}-clip-path`;
  const chartContainerProps = _extends({}, other, {
    series: series.map((s) => _extends({
      disableHighlight: !!disableLineItemHighlight,
      type: "line"
    }, s)),
    width,
    height,
    margin,
    colors,
    dataset,
    xAxis: xAxis ?? [{
      id: DEFAULT_X_AXIS_KEY,
      scaleType: "point",
      data: Array.from({
        length: Math.max(...series.map((s) => (s.data ?? dataset ?? []).length))
      }, (_, index) => index)
    }],
    yAxis,
    sx,
    highlightedItem,
    onHighlightChange,
    disableAxisListener: (tooltip == null ? void 0 : tooltip.trigger) !== "axis" && (axisHighlight == null ? void 0 : axisHighlight.x) === "none" && (axisHighlight == null ? void 0 : axisHighlight.y) === "none" && !onAxisClick,
    className,
    skipAnimation
  });
  const axisClickHandlerProps = {
    onAxisClick
  };
  const gridProps = {
    vertical: grid == null ? void 0 : grid.vertical,
    horizontal: grid == null ? void 0 : grid.horizontal
  };
  const clipPathGroupProps = {
    clipPath: `url(#${clipPathId})`
  };
  const clipPathProps = {
    id: clipPathId
  };
  const areaPlotProps = {
    slots,
    slotProps,
    onItemClick: onAreaClick
  };
  const linePlotProps = {
    slots,
    slotProps,
    onItemClick: onLineClick
  };
  const markPlotProps = {
    slots,
    slotProps,
    onItemClick: onMarkClick,
    skipAnimation,
    experimentalRendering: experimentalMarkRendering
  };
  const overlayProps = {
    slots,
    slotProps,
    loading
  };
  const chartsAxisProps = {
    topAxis,
    leftAxis,
    rightAxis,
    bottomAxis,
    slots,
    slotProps
  };
  const axisHighlightProps = _extends({
    x: "line"
  }, axisHighlight);
  const lineHighlightPlotProps = {
    slots,
    slotProps
  };
  const legendProps = _extends({}, legend, {
    slots,
    slotProps
  });
  const tooltipProps = _extends({}, tooltip, {
    slots,
    slotProps
  });
  return {
    chartContainerProps,
    axisClickHandlerProps,
    gridProps,
    clipPathProps,
    clipPathGroupProps,
    areaPlotProps,
    linePlotProps,
    markPlotProps,
    overlayProps,
    chartsAxisProps,
    axisHighlightProps,
    lineHighlightPlotProps,
    legendProps,
    tooltipProps,
    children
  };
};

// node_modules/@mui/x-charts/LineChart/LineChart.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var LineChart = React30.forwardRef(function LineChart2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiLineChart"
  });
  const {
    chartContainerProps,
    axisClickHandlerProps,
    gridProps,
    clipPathProps,
    clipPathGroupProps,
    areaPlotProps,
    linePlotProps,
    markPlotProps,
    overlayProps,
    chartsAxisProps,
    axisHighlightProps,
    lineHighlightPlotProps,
    legendProps,
    tooltipProps,
    children
  } = useLineChartProps(props);
  return (0, import_jsx_runtime29.jsxs)(ResponsiveChartContainer, _extends({
    ref
  }, chartContainerProps, {
    children: [props.onAxisClick && (0, import_jsx_runtime29.jsx)(ChartsOnAxisClickHandler, _extends({}, axisClickHandlerProps)), (0, import_jsx_runtime29.jsx)(ChartsGrid, _extends({}, gridProps)), (0, import_jsx_runtime29.jsxs)("g", _extends({}, clipPathGroupProps, {
      children: [(0, import_jsx_runtime29.jsx)(AreaPlot, _extends({}, areaPlotProps)), (0, import_jsx_runtime29.jsx)(LinePlot, _extends({}, linePlotProps)), (0, import_jsx_runtime29.jsx)(ChartsOverlay, _extends({}, overlayProps)), (0, import_jsx_runtime29.jsx)(ChartsAxisHighlight, _extends({}, axisHighlightProps))]
    })), (0, import_jsx_runtime29.jsx)(ChartsAxis, _extends({}, chartsAxisProps)), (0, import_jsx_runtime29.jsx)("g", {
      "data-drawing-container": true,
      children: (0, import_jsx_runtime29.jsx)(MarkPlot, _extends({}, markPlotProps))
    }), (0, import_jsx_runtime29.jsx)(LineHighlightPlot, _extends({}, lineHighlightPlotProps)), (0, import_jsx_runtime29.jsx)(ChartsLegend, _extends({}, legendProps)), !props.loading && (0, import_jsx_runtime29.jsx)(ChartsTooltip, _extends({}, tooltipProps)), (0, import_jsx_runtime29.jsx)(ChartsClipPath, _extends({}, clipPathProps)), children]
  }));
});
true ? LineChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The configuration of axes highlight.
   * @see See {@link https://mui.com/x/react-charts/highlighting highlighting docs} for more details.
   * @default { x: 'line' }
   */
  axisHighlight: import_prop_types22.default.shape({
    x: import_prop_types22.default.oneOf(["band", "line", "none"]),
    y: import_prop_types22.default.oneOf(["band", "line", "none"])
  }),
  /**
   * Indicate which axis to display the bottom of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default xAxisIds[0] The id of the first provided axis
   */
  bottomAxis: import_prop_types22.default.oneOfType([import_prop_types22.default.object, import_prop_types22.default.string]),
  children: import_prop_types22.default.node,
  className: import_prop_types22.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types22.default.oneOfType([import_prop_types22.default.arrayOf(import_prop_types22.default.string), import_prop_types22.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types22.default.arrayOf(import_prop_types22.default.object),
  desc: import_prop_types22.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types22.default.bool,
  /**
   * If `true`, render the line highlight item.
   */
  disableLineItemHighlight: import_prop_types22.default.bool,
  /**
   * If `true` marks will render `<circle />` instead of `<path />` and drop theme override for faster rendering.
   */
  experimentalMarkRendering: import_prop_types22.default.bool,
  /**
   * Option to display a cartesian grid in the background.
   */
  grid: import_prop_types22.default.shape({
    horizontal: import_prop_types22.default.bool,
    vertical: import_prop_types22.default.bool
  }),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types22.default.number,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types22.default.shape({
    dataIndex: import_prop_types22.default.number,
    seriesId: import_prop_types22.default.oneOfType([import_prop_types22.default.number, import_prop_types22.default.string])
  }),
  /**
   * Indicate which axis to display the left of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default yAxisIds[0] The id of the first provided axis
   */
  leftAxis: import_prop_types22.default.oneOfType([import_prop_types22.default.object, import_prop_types22.default.string]),
  /**
   * @deprecated Consider using `slotProps.legend` instead.
   */
  legend: import_prop_types22.default.shape({
    classes: import_prop_types22.default.object,
    direction: import_prop_types22.default.oneOf(["column", "row"]),
    hidden: import_prop_types22.default.bool,
    itemGap: import_prop_types22.default.number,
    itemMarkHeight: import_prop_types22.default.number,
    itemMarkWidth: import_prop_types22.default.number,
    labelStyle: import_prop_types22.default.object,
    markGap: import_prop_types22.default.number,
    onItemClick: import_prop_types22.default.func,
    padding: import_prop_types22.default.oneOfType([import_prop_types22.default.number, import_prop_types22.default.shape({
      bottom: import_prop_types22.default.number,
      left: import_prop_types22.default.number,
      right: import_prop_types22.default.number,
      top: import_prop_types22.default.number
    })]),
    position: import_prop_types22.default.shape({
      horizontal: import_prop_types22.default.oneOf(["left", "middle", "right"]).isRequired,
      vertical: import_prop_types22.default.oneOf(["bottom", "middle", "top"]).isRequired
    }),
    slotProps: import_prop_types22.default.object,
    slots: import_prop_types22.default.object
  }),
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types22.default.bool,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types22.default.shape({
    bottom: import_prop_types22.default.number,
    left: import_prop_types22.default.number,
    right: import_prop_types22.default.number,
    top: import_prop_types22.default.number
  }),
  /**
   * Callback fired when an area element is clicked.
   */
  onAreaClick: import_prop_types22.default.func,
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | AxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types22.default.func,
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types22.default.func,
  /**
   * Callback fired when a line element is clicked.
   */
  onLineClick: import_prop_types22.default.func,
  /**
   * Callback fired when a mark element is clicked.
   */
  onMarkClick: import_prop_types22.default.func,
  /**
   * The chart will try to wait for the parent container to resolve its size
   * before it renders for the first time.
   *
   * This can be useful in some scenarios where the chart appear to grow after
   * the first render, like when used inside a grid.
   *
   * @default false
   */
  resolveSizeBeforeRender: import_prop_types22.default.bool,
  /**
   * Indicate which axis to display the right of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default null
   */
  rightAxis: import_prop_types22.default.oneOfType([import_prop_types22.default.object, import_prop_types22.default.string]),
  /**
   * The series to display in the line chart.
   * An array of [[LineSeriesType]] objects.
   */
  series: import_prop_types22.default.arrayOf(import_prop_types22.default.object).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types22.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types22.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types22.default.object,
  sx: import_prop_types22.default.oneOfType([import_prop_types22.default.arrayOf(import_prop_types22.default.oneOfType([import_prop_types22.default.func, import_prop_types22.default.object, import_prop_types22.default.bool])), import_prop_types22.default.func, import_prop_types22.default.object]),
  title: import_prop_types22.default.string,
  /**
   * The configuration of the tooltip.
   * @see See {@link https://mui.com/x/react-charts/tooltip/ tooltip docs} for more details.
   * @default { trigger: 'item' }
   */
  tooltip: import_prop_types22.default.shape({
    axisContent: import_prop_types22.default.elementType,
    classes: import_prop_types22.default.object,
    itemContent: import_prop_types22.default.elementType,
    slotProps: import_prop_types22.default.object,
    slots: import_prop_types22.default.object,
    trigger: import_prop_types22.default.oneOf(["axis", "item", "none"])
  }),
  /**
   * Indicate which axis to display the top of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default null
   */
  topAxis: import_prop_types22.default.oneOfType([import_prop_types22.default.object, import_prop_types22.default.string]),
  viewBox: import_prop_types22.default.shape({
    height: import_prop_types22.default.number,
    width: import_prop_types22.default.number,
    x: import_prop_types22.default.number,
    y: import_prop_types22.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types22.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types22.default.arrayOf(import_prop_types22.default.shape({
    classes: import_prop_types22.default.object,
    colorMap: import_prop_types22.default.oneOfType([import_prop_types22.default.shape({
      colors: import_prop_types22.default.arrayOf(import_prop_types22.default.string).isRequired,
      type: import_prop_types22.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types22.default.string,
      values: import_prop_types22.default.arrayOf(import_prop_types22.default.oneOfType([import_prop_types22.default.instanceOf(Date), import_prop_types22.default.number, import_prop_types22.default.string]).isRequired)
    }), import_prop_types22.default.shape({
      color: import_prop_types22.default.oneOfType([import_prop_types22.default.arrayOf(import_prop_types22.default.string.isRequired), import_prop_types22.default.func]).isRequired,
      max: import_prop_types22.default.oneOfType([import_prop_types22.default.instanceOf(Date), import_prop_types22.default.number]),
      min: import_prop_types22.default.oneOfType([import_prop_types22.default.instanceOf(Date), import_prop_types22.default.number]),
      type: import_prop_types22.default.oneOf(["continuous"]).isRequired
    }), import_prop_types22.default.shape({
      colors: import_prop_types22.default.arrayOf(import_prop_types22.default.string).isRequired,
      thresholds: import_prop_types22.default.arrayOf(import_prop_types22.default.oneOfType([import_prop_types22.default.instanceOf(Date), import_prop_types22.default.number]).isRequired).isRequired,
      type: import_prop_types22.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types22.default.array,
    dataKey: import_prop_types22.default.string,
    disableLine: import_prop_types22.default.bool,
    disableTicks: import_prop_types22.default.bool,
    domainLimit: import_prop_types22.default.oneOfType([import_prop_types22.default.oneOf(["nice", "strict"]), import_prop_types22.default.func]),
    fill: import_prop_types22.default.string,
    hideTooltip: import_prop_types22.default.bool,
    id: import_prop_types22.default.oneOfType([import_prop_types22.default.number, import_prop_types22.default.string]),
    label: import_prop_types22.default.string,
    labelFontSize: import_prop_types22.default.number,
    labelStyle: import_prop_types22.default.object,
    max: import_prop_types22.default.oneOfType([import_prop_types22.default.instanceOf(Date), import_prop_types22.default.number]),
    min: import_prop_types22.default.oneOfType([import_prop_types22.default.instanceOf(Date), import_prop_types22.default.number]),
    position: import_prop_types22.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types22.default.bool,
    scaleType: import_prop_types22.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types22.default.object,
    slots: import_prop_types22.default.object,
    stroke: import_prop_types22.default.string,
    sx: import_prop_types22.default.oneOfType([import_prop_types22.default.arrayOf(import_prop_types22.default.oneOfType([import_prop_types22.default.func, import_prop_types22.default.object, import_prop_types22.default.bool])), import_prop_types22.default.func, import_prop_types22.default.object]),
    tickFontSize: import_prop_types22.default.number,
    tickInterval: import_prop_types22.default.oneOfType([import_prop_types22.default.oneOf(["auto"]), import_prop_types22.default.array, import_prop_types22.default.func]),
    tickLabelInterval: import_prop_types22.default.oneOfType([import_prop_types22.default.oneOf(["auto"]), import_prop_types22.default.func]),
    tickLabelPlacement: import_prop_types22.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types22.default.object,
    tickMaxStep: import_prop_types22.default.number,
    tickMinStep: import_prop_types22.default.number,
    tickNumber: import_prop_types22.default.number,
    tickPlacement: import_prop_types22.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types22.default.number,
    valueFormatter: import_prop_types22.default.func
  })),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types22.default.arrayOf(import_prop_types22.default.shape({
    classes: import_prop_types22.default.object,
    colorMap: import_prop_types22.default.oneOfType([import_prop_types22.default.shape({
      colors: import_prop_types22.default.arrayOf(import_prop_types22.default.string).isRequired,
      type: import_prop_types22.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types22.default.string,
      values: import_prop_types22.default.arrayOf(import_prop_types22.default.oneOfType([import_prop_types22.default.instanceOf(Date), import_prop_types22.default.number, import_prop_types22.default.string]).isRequired)
    }), import_prop_types22.default.shape({
      color: import_prop_types22.default.oneOfType([import_prop_types22.default.arrayOf(import_prop_types22.default.string.isRequired), import_prop_types22.default.func]).isRequired,
      max: import_prop_types22.default.oneOfType([import_prop_types22.default.instanceOf(Date), import_prop_types22.default.number]),
      min: import_prop_types22.default.oneOfType([import_prop_types22.default.instanceOf(Date), import_prop_types22.default.number]),
      type: import_prop_types22.default.oneOf(["continuous"]).isRequired
    }), import_prop_types22.default.shape({
      colors: import_prop_types22.default.arrayOf(import_prop_types22.default.string).isRequired,
      thresholds: import_prop_types22.default.arrayOf(import_prop_types22.default.oneOfType([import_prop_types22.default.instanceOf(Date), import_prop_types22.default.number]).isRequired).isRequired,
      type: import_prop_types22.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types22.default.array,
    dataKey: import_prop_types22.default.string,
    disableLine: import_prop_types22.default.bool,
    disableTicks: import_prop_types22.default.bool,
    domainLimit: import_prop_types22.default.oneOfType([import_prop_types22.default.oneOf(["nice", "strict"]), import_prop_types22.default.func]),
    fill: import_prop_types22.default.string,
    hideTooltip: import_prop_types22.default.bool,
    id: import_prop_types22.default.oneOfType([import_prop_types22.default.number, import_prop_types22.default.string]),
    label: import_prop_types22.default.string,
    labelFontSize: import_prop_types22.default.number,
    labelStyle: import_prop_types22.default.object,
    max: import_prop_types22.default.oneOfType([import_prop_types22.default.instanceOf(Date), import_prop_types22.default.number]),
    min: import_prop_types22.default.oneOfType([import_prop_types22.default.instanceOf(Date), import_prop_types22.default.number]),
    position: import_prop_types22.default.oneOf(["left", "right"]),
    reverse: import_prop_types22.default.bool,
    scaleType: import_prop_types22.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types22.default.object,
    slots: import_prop_types22.default.object,
    stroke: import_prop_types22.default.string,
    sx: import_prop_types22.default.oneOfType([import_prop_types22.default.arrayOf(import_prop_types22.default.oneOfType([import_prop_types22.default.func, import_prop_types22.default.object, import_prop_types22.default.bool])), import_prop_types22.default.func, import_prop_types22.default.object]),
    tickFontSize: import_prop_types22.default.number,
    tickInterval: import_prop_types22.default.oneOfType([import_prop_types22.default.oneOf(["auto"]), import_prop_types22.default.array, import_prop_types22.default.func]),
    tickLabelInterval: import_prop_types22.default.oneOfType([import_prop_types22.default.oneOf(["auto"]), import_prop_types22.default.func]),
    tickLabelPlacement: import_prop_types22.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types22.default.object,
    tickMaxStep: import_prop_types22.default.number,
    tickMinStep: import_prop_types22.default.number,
    tickNumber: import_prop_types22.default.number,
    tickPlacement: import_prop_types22.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types22.default.number,
    valueFormatter: import_prop_types22.default.func
  }))
} : void 0;

// node_modules/@mui/x-charts/ScatterChart/ScatterChart.js
var React33 = __toESM(require_react());
var import_prop_types25 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/ScatterChart/ScatterPlot.js
var React32 = __toESM(require_react());
var import_prop_types24 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/ScatterChart/Scatter.js
var React31 = __toESM(require_react());
var import_prop_types23 = __toESM(require_prop_types());
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
function Scatter(props) {
  const {
    series,
    xScale,
    yScale,
    color: color2,
    colorGetter,
    markerSize,
    onItemClick
  } = props;
  const drawingArea = useDrawingArea();
  const {
    useVoronoiInteraction
  } = React31.useContext(InteractionContext);
  const skipInteractionHandlers = useVoronoiInteraction || series.disableHover;
  const getInteractionItemProps = useInteractionItemProps(skipInteractionHandlers);
  const {
    isFaded,
    isHighlighted
  } = useHighlighted();
  const cleanData = React31.useMemo(() => {
    const getXPosition = getValueToPositionMapper(xScale);
    const getYPosition = getValueToPositionMapper(yScale);
    const temp = [];
    for (let i = 0; i < series.data.length; i += 1) {
      const scatterPoint = series.data[i];
      const x = getXPosition(scatterPoint.x);
      const y = getYPosition(scatterPoint.y);
      const isInRange = drawingArea.isPointInside({
        x,
        y
      });
      const pointCtx = {
        type: "scatter",
        seriesId: series.id,
        dataIndex: i
      };
      if (isInRange) {
        const currentItem = {
          seriesId: pointCtx.seriesId,
          dataIndex: pointCtx.dataIndex
        };
        const isItemHighlighted = isHighlighted(currentItem);
        temp.push({
          x,
          y,
          isHighlighted: isItemHighlighted,
          isFaded: !isItemHighlighted && isFaded(currentItem),
          interactionProps: getInteractionItemProps(pointCtx),
          id: scatterPoint.id,
          dataIndex: i,
          color: colorGetter ? colorGetter(i) : color2
        });
      }
    }
    return temp;
  }, [xScale, yScale, drawingArea, series.data, series.id, isHighlighted, isFaded, getInteractionItemProps, colorGetter, color2]);
  return (0, import_jsx_runtime30.jsx)("g", {
    children: cleanData.map((dataPoint) => (0, import_jsx_runtime30.jsx)("circle", _extends({
      cx: 0,
      cy: 0,
      r: (dataPoint.isHighlighted ? 1.2 : 1) * markerSize,
      transform: `translate(${dataPoint.x}, ${dataPoint.y})`,
      fill: dataPoint.color,
      opacity: dataPoint.isFaded && 0.3 || 1,
      onClick: onItemClick && ((event) => onItemClick(event, {
        type: "scatter",
        seriesId: series.id,
        dataIndex: dataPoint.dataIndex
      })),
      cursor: onItemClick ? "pointer" : "unset"
    }, dataPoint.interactionProps), dataPoint.id))
  });
}
true ? Scatter.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  color: import_prop_types23.default.string.isRequired,
  colorGetter: import_prop_types23.default.func,
  markerSize: import_prop_types23.default.number.isRequired,
  /**
   * Callback fired when clicking on a scatter item.
   * @param {MouseEvent} event Mouse event recorded on the `<svg/>` element.
   * @param {ScatterItemIdentifier} scatterItemIdentifier The scatter item identifier.
   */
  onItemClick: import_prop_types23.default.func,
  series: import_prop_types23.default.object.isRequired,
  xScale: import_prop_types23.default.func.isRequired,
  yScale: import_prop_types23.default.func.isRequired
} : void 0;

// node_modules/@mui/x-charts/ScatterChart/ScatterPlot.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
function ScatterPlot(props) {
  const {
    slots,
    slotProps,
    onItemClick
  } = props;
  const seriesData = useScatterSeries();
  const axisData = useCartesianContext();
  const {
    zAxis,
    zAxisIds
  } = React32.useContext(ZAxisContext);
  if (seriesData === void 0) {
    return null;
  }
  const {
    series,
    seriesOrder
  } = seriesData;
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = axisData;
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  const defaultZAxisId = zAxisIds[0];
  const ScatterItems = (slots == null ? void 0 : slots.scatter) ?? Scatter;
  return (0, import_jsx_runtime31.jsx)(React32.Fragment, {
    children: seriesOrder.map((seriesId) => {
      const {
        id,
        xAxisKey,
        yAxisKey,
        zAxisKey,
        xAxisId,
        yAxisId,
        zAxisId,
        markerSize,
        color: color2
      } = series[seriesId];
      const colorGetter = getColor_default2(series[seriesId], xAxis[xAxisId ?? xAxisKey ?? defaultXAxisId], yAxis[yAxisId ?? yAxisKey ?? defaultYAxisId], zAxis[zAxisId ?? zAxisKey ?? defaultZAxisId]);
      const xScale = xAxis[xAxisId ?? xAxisKey ?? defaultXAxisId].scale;
      const yScale = yAxis[yAxisId ?? yAxisKey ?? defaultYAxisId].scale;
      return (0, import_jsx_runtime31.jsx)(ScatterItems, _extends({
        xScale,
        yScale,
        color: color2,
        colorGetter,
        markerSize: markerSize ?? 4,
        series: series[seriesId],
        onItemClick
      }, slotProps == null ? void 0 : slotProps.scatter), id);
    })
  });
}
true ? ScatterPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when clicking on a scatter item.
   * @param {MouseEvent} event Mouse event recorded on the `<svg/>` element.
   * @param {ScatterItemIdentifier} scatterItemIdentifier The scatter item identifier.
   */
  onItemClick: import_prop_types24.default.func,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types24.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types24.default.object
} : void 0;

// node_modules/@mui/x-charts/ScatterChart/useScatterChartProps.js
var _excluded21 = ["xAxis", "yAxis", "zAxis", "series", "tooltip", "axisHighlight", "voronoiMaxRadius", "disableVoronoi", "legend", "width", "height", "margin", "colors", "sx", "grid", "topAxis", "leftAxis", "rightAxis", "bottomAxis", "onItemClick", "children", "slots", "slotProps", "loading", "highlightedItem", "onHighlightChange", "className"];
var useScatterChartProps = (props) => {
  const {
    xAxis,
    yAxis,
    zAxis,
    series,
    tooltip,
    axisHighlight,
    voronoiMaxRadius,
    disableVoronoi,
    legend,
    width,
    height,
    margin,
    colors,
    sx,
    grid,
    topAxis,
    leftAxis,
    rightAxis,
    bottomAxis,
    onItemClick,
    children,
    slots,
    slotProps,
    loading,
    highlightedItem,
    onHighlightChange,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded21);
  const chartContainerProps = _extends({}, other, {
    series: series.map((s) => _extends({
      type: "scatter"
    }, s)),
    width,
    height,
    margin,
    colors,
    xAxis,
    yAxis,
    sx,
    highlightedItem,
    onHighlightChange,
    className
  });
  const zAxisProps = {
    zAxis
  };
  const voronoiHandlerProps = {
    voronoiMaxRadius,
    onItemClick
  };
  const chartsAxisProps = {
    topAxis,
    leftAxis,
    rightAxis,
    bottomAxis,
    slots,
    slotProps
  };
  const gridProps = {
    vertical: grid == null ? void 0 : grid.vertical,
    horizontal: grid == null ? void 0 : grid.horizontal
  };
  const scatterPlotProps = {
    onItemClick: disableVoronoi ? onItemClick : void 0,
    slots,
    slotProps
  };
  const overlayProps = {
    loading,
    slots,
    slotProps
  };
  const legendProps = _extends({}, legend, {
    slots,
    slotProps
  });
  const axisHighlightProps = _extends({
    y: "none",
    x: "none"
  }, axisHighlight);
  const tooltipProps = _extends({
    trigger: "item"
  }, tooltip, {
    slots,
    slotProps
  });
  return {
    chartContainerProps,
    zAxisProps,
    voronoiHandlerProps,
    chartsAxisProps,
    gridProps,
    scatterPlotProps,
    overlayProps,
    legendProps,
    axisHighlightProps,
    tooltipProps,
    children
  };
};

// node_modules/@mui/x-charts/ScatterChart/ScatterChart.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
var ScatterChart = React33.forwardRef(function ScatterChart2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiScatterChart"
  });
  const {
    chartContainerProps,
    zAxisProps,
    voronoiHandlerProps,
    chartsAxisProps,
    gridProps,
    scatterPlotProps,
    overlayProps,
    legendProps,
    axisHighlightProps,
    tooltipProps,
    children
  } = useScatterChartProps(props);
  return (0, import_jsx_runtime32.jsx)(ResponsiveChartContainer, _extends({
    ref
  }, chartContainerProps, {
    children: (0, import_jsx_runtime32.jsxs)(ZAxisContextProvider, _extends({}, zAxisProps, {
      children: [!props.disableVoronoi && (0, import_jsx_runtime32.jsx)(ChartsVoronoiHandler, _extends({}, voronoiHandlerProps)), (0, import_jsx_runtime32.jsx)(ChartsAxis, _extends({}, chartsAxisProps)), (0, import_jsx_runtime32.jsx)(ChartsGrid, _extends({}, gridProps)), (0, import_jsx_runtime32.jsx)("g", {
        "data-drawing-container": true,
        children: (0, import_jsx_runtime32.jsx)(ScatterPlot, _extends({}, scatterPlotProps))
      }), (0, import_jsx_runtime32.jsx)(ChartsOverlay, _extends({}, overlayProps)), (0, import_jsx_runtime32.jsx)(ChartsLegend, _extends({}, legendProps)), (0, import_jsx_runtime32.jsx)(ChartsAxisHighlight, _extends({}, axisHighlightProps)), !props.loading && (0, import_jsx_runtime32.jsx)(ChartsTooltip, _extends({}, tooltipProps)), children]
    }))
  }));
});
true ? ScatterChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The configuration of axes highlight.
   * @see See {@link https://mui.com/x/react-charts/highlighting highlighting docs} for more details.
   * @default { x: 'none', y: 'none' }
   */
  axisHighlight: import_prop_types25.default.shape({
    x: import_prop_types25.default.oneOf(["band", "line", "none"]),
    y: import_prop_types25.default.oneOf(["band", "line", "none"])
  }),
  /**
   * Indicate which axis to display the bottom of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default xAxisIds[0] The id of the first provided axis
   */
  bottomAxis: import_prop_types25.default.oneOfType([import_prop_types25.default.object, import_prop_types25.default.string]),
  children: import_prop_types25.default.node,
  className: import_prop_types25.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types25.default.oneOfType([import_prop_types25.default.arrayOf(import_prop_types25.default.string), import_prop_types25.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types25.default.arrayOf(import_prop_types25.default.object),
  desc: import_prop_types25.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types25.default.bool,
  /**
   * If true, the interaction will not use the Voronoi cell and fall back to hover events.
   * @default false
   */
  disableVoronoi: import_prop_types25.default.bool,
  /**
   * Option to display a cartesian grid in the background.
   */
  grid: import_prop_types25.default.shape({
    horizontal: import_prop_types25.default.bool,
    vertical: import_prop_types25.default.bool
  }),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types25.default.number,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types25.default.shape({
    dataIndex: import_prop_types25.default.number,
    seriesId: import_prop_types25.default.oneOfType([import_prop_types25.default.number, import_prop_types25.default.string])
  }),
  /**
   * Indicate which axis to display the left of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default yAxisIds[0] The id of the first provided axis
   */
  leftAxis: import_prop_types25.default.oneOfType([import_prop_types25.default.object, import_prop_types25.default.string]),
  /**
   * @deprecated Consider using `slotProps.legend` instead.
   */
  legend: import_prop_types25.default.shape({
    classes: import_prop_types25.default.object,
    direction: import_prop_types25.default.oneOf(["column", "row"]),
    hidden: import_prop_types25.default.bool,
    itemGap: import_prop_types25.default.number,
    itemMarkHeight: import_prop_types25.default.number,
    itemMarkWidth: import_prop_types25.default.number,
    labelStyle: import_prop_types25.default.object,
    markGap: import_prop_types25.default.number,
    onItemClick: import_prop_types25.default.func,
    padding: import_prop_types25.default.oneOfType([import_prop_types25.default.number, import_prop_types25.default.shape({
      bottom: import_prop_types25.default.number,
      left: import_prop_types25.default.number,
      right: import_prop_types25.default.number,
      top: import_prop_types25.default.number
    })]),
    position: import_prop_types25.default.shape({
      horizontal: import_prop_types25.default.oneOf(["left", "middle", "right"]).isRequired,
      vertical: import_prop_types25.default.oneOf(["bottom", "middle", "top"]).isRequired
    }),
    slotProps: import_prop_types25.default.object,
    slots: import_prop_types25.default.object
  }),
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types25.default.bool,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types25.default.shape({
    bottom: import_prop_types25.default.number,
    left: import_prop_types25.default.number,
    right: import_prop_types25.default.number,
    top: import_prop_types25.default.number
  }),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types25.default.func,
  /**
   * Callback fired when clicking on a scatter item.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element if using Voronoi cells. Or the Mouse event from the scatter element, when `disableVoronoi=true`.
   * @param {ScatterItemIdentifier} scatterItemIdentifier The scatter item identifier.
   */
  onItemClick: import_prop_types25.default.func,
  /**
   * The chart will try to wait for the parent container to resolve its size
   * before it renders for the first time.
   *
   * This can be useful in some scenarios where the chart appear to grow after
   * the first render, like when used inside a grid.
   *
   * @default false
   */
  resolveSizeBeforeRender: import_prop_types25.default.bool,
  /**
   * Indicate which axis to display the right of the charts.
   * Can be a string (the id of the axis) or an object `ChartsYAxisProps`.
   * @default null
   */
  rightAxis: import_prop_types25.default.oneOfType([import_prop_types25.default.object, import_prop_types25.default.string]),
  /**
   * The series to display in the scatter chart.
   * An array of [[ScatterSeriesType]] objects.
   */
  series: import_prop_types25.default.arrayOf(import_prop_types25.default.object).isRequired,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types25.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types25.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types25.default.object,
  sx: import_prop_types25.default.oneOfType([import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.func, import_prop_types25.default.object, import_prop_types25.default.bool])), import_prop_types25.default.func, import_prop_types25.default.object]),
  title: import_prop_types25.default.string,
  /**
   * The configuration of the tooltip.
   * @see See {@link https://mui.com/x/react-charts/tooltip/ tooltip docs} for more details.
   * @default { trigger: 'item' }
   */
  tooltip: import_prop_types25.default.shape({
    axisContent: import_prop_types25.default.elementType,
    classes: import_prop_types25.default.object,
    itemContent: import_prop_types25.default.elementType,
    slotProps: import_prop_types25.default.object,
    slots: import_prop_types25.default.object,
    trigger: import_prop_types25.default.oneOf(["axis", "item", "none"])
  }),
  /**
   * Indicate which axis to display the top of the charts.
   * Can be a string (the id of the axis) or an object `ChartsXAxisProps`.
   * @default null
   */
  topAxis: import_prop_types25.default.oneOfType([import_prop_types25.default.object, import_prop_types25.default.string]),
  viewBox: import_prop_types25.default.shape({
    height: import_prop_types25.default.number,
    width: import_prop_types25.default.number,
    x: import_prop_types25.default.number,
    y: import_prop_types25.default.number
  }),
  /**
   * Defines the maximal distance between a scatter point and the pointer that triggers the interaction.
   * If `undefined`, the radius is assumed to be infinite.
   */
  voronoiMaxRadius: import_prop_types25.default.number,
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types25.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types25.default.arrayOf(import_prop_types25.default.shape({
    classes: import_prop_types25.default.object,
    colorMap: import_prop_types25.default.oneOfType([import_prop_types25.default.shape({
      colors: import_prop_types25.default.arrayOf(import_prop_types25.default.string).isRequired,
      type: import_prop_types25.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types25.default.string,
      values: import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number, import_prop_types25.default.string]).isRequired)
    }), import_prop_types25.default.shape({
      color: import_prop_types25.default.oneOfType([import_prop_types25.default.arrayOf(import_prop_types25.default.string.isRequired), import_prop_types25.default.func]).isRequired,
      max: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
      min: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
      type: import_prop_types25.default.oneOf(["continuous"]).isRequired
    }), import_prop_types25.default.shape({
      colors: import_prop_types25.default.arrayOf(import_prop_types25.default.string).isRequired,
      thresholds: import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]).isRequired).isRequired,
      type: import_prop_types25.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types25.default.array,
    dataKey: import_prop_types25.default.string,
    disableLine: import_prop_types25.default.bool,
    disableTicks: import_prop_types25.default.bool,
    domainLimit: import_prop_types25.default.oneOfType([import_prop_types25.default.oneOf(["nice", "strict"]), import_prop_types25.default.func]),
    fill: import_prop_types25.default.string,
    hideTooltip: import_prop_types25.default.bool,
    id: import_prop_types25.default.oneOfType([import_prop_types25.default.number, import_prop_types25.default.string]),
    label: import_prop_types25.default.string,
    labelFontSize: import_prop_types25.default.number,
    labelStyle: import_prop_types25.default.object,
    max: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
    min: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
    position: import_prop_types25.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types25.default.bool,
    scaleType: import_prop_types25.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types25.default.object,
    slots: import_prop_types25.default.object,
    stroke: import_prop_types25.default.string,
    sx: import_prop_types25.default.oneOfType([import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.func, import_prop_types25.default.object, import_prop_types25.default.bool])), import_prop_types25.default.func, import_prop_types25.default.object]),
    tickFontSize: import_prop_types25.default.number,
    tickInterval: import_prop_types25.default.oneOfType([import_prop_types25.default.oneOf(["auto"]), import_prop_types25.default.array, import_prop_types25.default.func]),
    tickLabelInterval: import_prop_types25.default.oneOfType([import_prop_types25.default.oneOf(["auto"]), import_prop_types25.default.func]),
    tickLabelPlacement: import_prop_types25.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types25.default.object,
    tickMaxStep: import_prop_types25.default.number,
    tickMinStep: import_prop_types25.default.number,
    tickNumber: import_prop_types25.default.number,
    tickPlacement: import_prop_types25.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types25.default.number,
    valueFormatter: import_prop_types25.default.func
  })),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types25.default.arrayOf(import_prop_types25.default.shape({
    classes: import_prop_types25.default.object,
    colorMap: import_prop_types25.default.oneOfType([import_prop_types25.default.shape({
      colors: import_prop_types25.default.arrayOf(import_prop_types25.default.string).isRequired,
      type: import_prop_types25.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types25.default.string,
      values: import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number, import_prop_types25.default.string]).isRequired)
    }), import_prop_types25.default.shape({
      color: import_prop_types25.default.oneOfType([import_prop_types25.default.arrayOf(import_prop_types25.default.string.isRequired), import_prop_types25.default.func]).isRequired,
      max: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
      min: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
      type: import_prop_types25.default.oneOf(["continuous"]).isRequired
    }), import_prop_types25.default.shape({
      colors: import_prop_types25.default.arrayOf(import_prop_types25.default.string).isRequired,
      thresholds: import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]).isRequired).isRequired,
      type: import_prop_types25.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types25.default.array,
    dataKey: import_prop_types25.default.string,
    disableLine: import_prop_types25.default.bool,
    disableTicks: import_prop_types25.default.bool,
    domainLimit: import_prop_types25.default.oneOfType([import_prop_types25.default.oneOf(["nice", "strict"]), import_prop_types25.default.func]),
    fill: import_prop_types25.default.string,
    hideTooltip: import_prop_types25.default.bool,
    id: import_prop_types25.default.oneOfType([import_prop_types25.default.number, import_prop_types25.default.string]),
    label: import_prop_types25.default.string,
    labelFontSize: import_prop_types25.default.number,
    labelStyle: import_prop_types25.default.object,
    max: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
    min: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
    position: import_prop_types25.default.oneOf(["left", "right"]),
    reverse: import_prop_types25.default.bool,
    scaleType: import_prop_types25.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types25.default.object,
    slots: import_prop_types25.default.object,
    stroke: import_prop_types25.default.string,
    sx: import_prop_types25.default.oneOfType([import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.func, import_prop_types25.default.object, import_prop_types25.default.bool])), import_prop_types25.default.func, import_prop_types25.default.object]),
    tickFontSize: import_prop_types25.default.number,
    tickInterval: import_prop_types25.default.oneOfType([import_prop_types25.default.oneOf(["auto"]), import_prop_types25.default.array, import_prop_types25.default.func]),
    tickLabelInterval: import_prop_types25.default.oneOfType([import_prop_types25.default.oneOf(["auto"]), import_prop_types25.default.func]),
    tickLabelPlacement: import_prop_types25.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types25.default.object,
    tickMaxStep: import_prop_types25.default.number,
    tickMinStep: import_prop_types25.default.number,
    tickNumber: import_prop_types25.default.number,
    tickPlacement: import_prop_types25.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types25.default.number,
    valueFormatter: import_prop_types25.default.func
  })),
  /**
   * The configuration of the z-axes.
   */
  zAxis: import_prop_types25.default.arrayOf(import_prop_types25.default.shape({
    colorMap: import_prop_types25.default.oneOfType([import_prop_types25.default.shape({
      colors: import_prop_types25.default.arrayOf(import_prop_types25.default.string).isRequired,
      type: import_prop_types25.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types25.default.string,
      values: import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number, import_prop_types25.default.string]).isRequired)
    }), import_prop_types25.default.shape({
      color: import_prop_types25.default.oneOfType([import_prop_types25.default.arrayOf(import_prop_types25.default.string.isRequired), import_prop_types25.default.func]).isRequired,
      max: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
      min: import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]),
      type: import_prop_types25.default.oneOf(["continuous"]).isRequired
    }), import_prop_types25.default.shape({
      colors: import_prop_types25.default.arrayOf(import_prop_types25.default.string).isRequired,
      thresholds: import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.instanceOf(Date), import_prop_types25.default.number]).isRequired).isRequired,
      type: import_prop_types25.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types25.default.array,
    dataKey: import_prop_types25.default.string,
    id: import_prop_types25.default.string,
    max: import_prop_types25.default.number,
    min: import_prop_types25.default.number
  }))
} : void 0;

// node_modules/@mui/x-charts/SparkLineChart/SparkLineChart.js
var React34 = __toESM(require_react());
var import_prop_types26 = __toESM(require_prop_types());
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
var _excluded23 = ["xAxis", "yAxis", "width", "height", "margin", "colors", "sx", "showTooltip", "tooltip", "showHighlight", "axisHighlight", "children", "slots", "slotProps", "data", "plotType", "valueFormatter", "area", "curve", "className"];
var SPARKLINE_DEFAULT_MARGIN = {
  top: 5,
  bottom: 5,
  left: 5,
  right: 5
};
var SparkLineChart = React34.forwardRef(function SparkLineChart2(props, ref) {
  const {
    xAxis,
    yAxis,
    width,
    height,
    margin = SPARKLINE_DEFAULT_MARGIN,
    colors,
    sx,
    showTooltip,
    tooltip,
    showHighlight,
    axisHighlight: inAxisHighlight,
    children,
    slots,
    slotProps,
    data,
    plotType = "line",
    valueFormatter = (value) => value === null ? "" : value.toString(),
    area,
    curve = "linear",
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded23);
  const defaultXHighlight = showHighlight && plotType === "bar" ? {
    x: "band"
  } : {
    x: "none"
  };
  const axisHighlight = _extends({}, defaultXHighlight, inAxisHighlight);
  return (0, import_jsx_runtime33.jsxs)(ResponsiveChartContainer, _extends({}, other, {
    ref,
    series: [_extends({
      type: plotType,
      data,
      valueFormatter
    }, plotType === "bar" ? {} : {
      area,
      curve,
      disableHighlight: !showHighlight
    })],
    width,
    height,
    margin,
    className,
    xAxis: [_extends({
      id: DEFAULT_X_AXIS_KEY,
      scaleType: plotType === "bar" ? "band" : "point",
      data: Array.from({
        length: data.length
      }, (_, index) => index),
      hideTooltip: xAxis === void 0
    }, xAxis)],
    yAxis: [_extends({
      id: DEFAULT_X_AXIS_KEY
    }, yAxis)],
    colors,
    sx,
    disableAxisListener: (!showTooltip || (tooltip == null ? void 0 : tooltip.trigger) !== "axis") && (axisHighlight == null ? void 0 : axisHighlight.x) === "none" && (axisHighlight == null ? void 0 : axisHighlight.y) === "none",
    children: [plotType === "bar" && (0, import_jsx_runtime33.jsx)(BarPlot, {
      skipAnimation: true,
      slots,
      slotProps,
      sx: {
        shapeRendering: "auto"
      }
    }), plotType === "line" && (0, import_jsx_runtime33.jsxs)(React34.Fragment, {
      children: [(0, import_jsx_runtime33.jsx)(AreaPlot, {
        skipAnimation: true,
        slots,
        slotProps
      }), (0, import_jsx_runtime33.jsx)(LinePlot, {
        skipAnimation: true,
        slots,
        slotProps
      }), (0, import_jsx_runtime33.jsx)(LineHighlightPlot, {
        slots,
        slotProps
      })]
    }), (0, import_jsx_runtime33.jsx)(ChartsAxisHighlight, _extends({}, axisHighlight)), showTooltip && (0, import_jsx_runtime33.jsx)(ChartsTooltip, _extends({}, tooltip, {
      slotProps,
      slots
    })), children]
  }));
});
true ? SparkLineChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Set to `true` to fill spark line area.
   * Has no effect if plotType='bar'.
   * @default false
   */
  area: import_prop_types26.default.bool,
  axisHighlight: import_prop_types26.default.shape({
    x: import_prop_types26.default.oneOf(["band", "line", "none"]),
    y: import_prop_types26.default.oneOf(["band", "line", "none"])
  }),
  children: import_prop_types26.default.node,
  className: import_prop_types26.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types26.default.oneOfType([import_prop_types26.default.arrayOf(import_prop_types26.default.string), import_prop_types26.default.func]),
  /**
   * @default 'linear'
   */
  curve: import_prop_types26.default.oneOf(["catmullRom", "linear", "monotoneX", "monotoneY", "natural", "step", "stepAfter", "stepBefore"]),
  /**
   * Data to plot.
   */
  data: import_prop_types26.default.arrayOf(import_prop_types26.default.number).isRequired,
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types26.default.arrayOf(import_prop_types26.default.object),
  desc: import_prop_types26.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types26.default.bool,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types26.default.number,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types26.default.shape({
    dataIndex: import_prop_types26.default.number,
    seriesId: import_prop_types26.default.oneOfType([import_prop_types26.default.number, import_prop_types26.default.string])
  }),
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default {
   *   top: 5,
   *   bottom: 5,
   *   left: 5,
   *   right: 5,
   * }
   */
  margin: import_prop_types26.default.shape({
    bottom: import_prop_types26.default.number,
    left: import_prop_types26.default.number,
    right: import_prop_types26.default.number,
    top: import_prop_types26.default.number
  }),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types26.default.func,
  /**
   * Type of plot used.
   * @default 'line'
   */
  plotType: import_prop_types26.default.oneOf(["bar", "line"]),
  /**
   * The chart will try to wait for the parent container to resolve its size
   * before it renders for the first time.
   *
   * This can be useful in some scenarios where the chart appear to grow after
   * the first render, like when used inside a grid.
   *
   * @default false
   */
  resolveSizeBeforeRender: import_prop_types26.default.bool,
  /**
   * Set to `true` to highlight the value.
   * With line, it shows a point.
   * With bar, it shows a highlight band.
   * @default false
   */
  showHighlight: import_prop_types26.default.bool,
  /**
   * Set to `true` to enable the tooltip in the sparkline.
   * @default false
   */
  showTooltip: import_prop_types26.default.bool,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types26.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types26.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types26.default.object,
  sx: import_prop_types26.default.oneOfType([import_prop_types26.default.arrayOf(import_prop_types26.default.oneOfType([import_prop_types26.default.func, import_prop_types26.default.object, import_prop_types26.default.bool])), import_prop_types26.default.func, import_prop_types26.default.object]),
  title: import_prop_types26.default.string,
  tooltip: import_prop_types26.default.shape({
    axisContent: import_prop_types26.default.elementType,
    classes: import_prop_types26.default.object,
    itemContent: import_prop_types26.default.elementType,
    slotProps: import_prop_types26.default.object,
    slots: import_prop_types26.default.object,
    trigger: import_prop_types26.default.oneOf(["axis", "item", "none"])
  }),
  /**
   * Formatter used by the tooltip.
   * @param {number} value The value to format.
   * @returns {string} the formatted value.
   * @default (value: number | null) => (value === null ? '' : value.toString())
   */
  valueFormatter: import_prop_types26.default.func,
  viewBox: import_prop_types26.default.shape({
    height: import_prop_types26.default.number,
    width: import_prop_types26.default.number,
    x: import_prop_types26.default.number,
    y: import_prop_types26.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types26.default.number,
  /**
   * The xAxis configuration.
   * Notice it is a single [[AxisConfig]] object, not an array of configuration.
   */
  xAxis: import_prop_types26.default.shape({
    classes: import_prop_types26.default.object,
    colorMap: import_prop_types26.default.oneOfType([import_prop_types26.default.shape({
      colors: import_prop_types26.default.arrayOf(import_prop_types26.default.string).isRequired,
      type: import_prop_types26.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types26.default.string,
      values: import_prop_types26.default.arrayOf(import_prop_types26.default.oneOfType([import_prop_types26.default.instanceOf(Date), import_prop_types26.default.number, import_prop_types26.default.string]).isRequired)
    }), import_prop_types26.default.shape({
      color: import_prop_types26.default.oneOfType([import_prop_types26.default.arrayOf(import_prop_types26.default.string.isRequired), import_prop_types26.default.func]).isRequired,
      max: import_prop_types26.default.oneOfType([import_prop_types26.default.instanceOf(Date), import_prop_types26.default.number]),
      min: import_prop_types26.default.oneOfType([import_prop_types26.default.instanceOf(Date), import_prop_types26.default.number]),
      type: import_prop_types26.default.oneOf(["continuous"]).isRequired
    }), import_prop_types26.default.shape({
      colors: import_prop_types26.default.arrayOf(import_prop_types26.default.string).isRequired,
      thresholds: import_prop_types26.default.arrayOf(import_prop_types26.default.oneOfType([import_prop_types26.default.instanceOf(Date), import_prop_types26.default.number]).isRequired).isRequired,
      type: import_prop_types26.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types26.default.array,
    dataKey: import_prop_types26.default.string,
    disableLine: import_prop_types26.default.bool,
    disableTicks: import_prop_types26.default.bool,
    domainLimit: import_prop_types26.default.oneOfType([import_prop_types26.default.oneOf(["nice", "strict"]), import_prop_types26.default.func]),
    fill: import_prop_types26.default.string,
    hideTooltip: import_prop_types26.default.bool,
    id: import_prop_types26.default.oneOfType([import_prop_types26.default.number, import_prop_types26.default.string]),
    label: import_prop_types26.default.string,
    labelFontSize: import_prop_types26.default.number,
    labelStyle: import_prop_types26.default.object,
    max: import_prop_types26.default.oneOfType([import_prop_types26.default.instanceOf(Date), import_prop_types26.default.number]),
    min: import_prop_types26.default.oneOfType([import_prop_types26.default.instanceOf(Date), import_prop_types26.default.number]),
    position: import_prop_types26.default.oneOf(["bottom", "top"]),
    reverse: import_prop_types26.default.bool,
    scaleType: import_prop_types26.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types26.default.object,
    slots: import_prop_types26.default.object,
    stroke: import_prop_types26.default.string,
    sx: import_prop_types26.default.oneOfType([import_prop_types26.default.arrayOf(import_prop_types26.default.oneOfType([import_prop_types26.default.func, import_prop_types26.default.object, import_prop_types26.default.bool])), import_prop_types26.default.func, import_prop_types26.default.object]),
    tickFontSize: import_prop_types26.default.number,
    tickInterval: import_prop_types26.default.oneOfType([import_prop_types26.default.oneOf(["auto"]), import_prop_types26.default.array, import_prop_types26.default.func]),
    tickLabelInterval: import_prop_types26.default.oneOfType([import_prop_types26.default.oneOf(["auto"]), import_prop_types26.default.func]),
    tickLabelPlacement: import_prop_types26.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types26.default.object,
    tickMaxStep: import_prop_types26.default.number,
    tickMinStep: import_prop_types26.default.number,
    tickNumber: import_prop_types26.default.number,
    tickPlacement: import_prop_types26.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types26.default.number,
    valueFormatter: import_prop_types26.default.func
  }),
  /**
   * The yAxis configuration.
   * Notice it is a single [[AxisConfig]] object, not an array of configuration.
   */
  yAxis: import_prop_types26.default.shape({
    classes: import_prop_types26.default.object,
    colorMap: import_prop_types26.default.oneOfType([import_prop_types26.default.shape({
      colors: import_prop_types26.default.arrayOf(import_prop_types26.default.string).isRequired,
      type: import_prop_types26.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types26.default.string,
      values: import_prop_types26.default.arrayOf(import_prop_types26.default.oneOfType([import_prop_types26.default.instanceOf(Date), import_prop_types26.default.number, import_prop_types26.default.string]).isRequired)
    }), import_prop_types26.default.shape({
      color: import_prop_types26.default.oneOfType([import_prop_types26.default.arrayOf(import_prop_types26.default.string.isRequired), import_prop_types26.default.func]).isRequired,
      max: import_prop_types26.default.oneOfType([import_prop_types26.default.instanceOf(Date), import_prop_types26.default.number]),
      min: import_prop_types26.default.oneOfType([import_prop_types26.default.instanceOf(Date), import_prop_types26.default.number]),
      type: import_prop_types26.default.oneOf(["continuous"]).isRequired
    }), import_prop_types26.default.shape({
      colors: import_prop_types26.default.arrayOf(import_prop_types26.default.string).isRequired,
      thresholds: import_prop_types26.default.arrayOf(import_prop_types26.default.oneOfType([import_prop_types26.default.instanceOf(Date), import_prop_types26.default.number]).isRequired).isRequired,
      type: import_prop_types26.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types26.default.array,
    dataKey: import_prop_types26.default.string,
    disableLine: import_prop_types26.default.bool,
    disableTicks: import_prop_types26.default.bool,
    domainLimit: import_prop_types26.default.oneOfType([import_prop_types26.default.oneOf(["nice", "strict"]), import_prop_types26.default.func]),
    fill: import_prop_types26.default.string,
    hideTooltip: import_prop_types26.default.bool,
    id: import_prop_types26.default.oneOfType([import_prop_types26.default.number, import_prop_types26.default.string]),
    label: import_prop_types26.default.string,
    labelFontSize: import_prop_types26.default.number,
    labelStyle: import_prop_types26.default.object,
    max: import_prop_types26.default.oneOfType([import_prop_types26.default.instanceOf(Date), import_prop_types26.default.number]),
    min: import_prop_types26.default.oneOfType([import_prop_types26.default.instanceOf(Date), import_prop_types26.default.number]),
    position: import_prop_types26.default.oneOf(["left", "right"]),
    reverse: import_prop_types26.default.bool,
    scaleType: import_prop_types26.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types26.default.object,
    slots: import_prop_types26.default.object,
    stroke: import_prop_types26.default.string,
    sx: import_prop_types26.default.oneOfType([import_prop_types26.default.arrayOf(import_prop_types26.default.oneOfType([import_prop_types26.default.func, import_prop_types26.default.object, import_prop_types26.default.bool])), import_prop_types26.default.func, import_prop_types26.default.object]),
    tickFontSize: import_prop_types26.default.number,
    tickInterval: import_prop_types26.default.oneOfType([import_prop_types26.default.oneOf(["auto"]), import_prop_types26.default.array, import_prop_types26.default.func]),
    tickLabelInterval: import_prop_types26.default.oneOfType([import_prop_types26.default.oneOf(["auto"]), import_prop_types26.default.func]),
    tickLabelPlacement: import_prop_types26.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types26.default.object,
    tickMaxStep: import_prop_types26.default.number,
    tickMinStep: import_prop_types26.default.number,
    tickNumber: import_prop_types26.default.number,
    tickPlacement: import_prop_types26.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types26.default.number,
    valueFormatter: import_prop_types26.default.func
  })
} : void 0;

// node_modules/@mui/x-charts/Gauge/Gauge.js
var React40 = __toESM(require_react());
var import_prop_types29 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/Gauge/GaugeContainer.js
var React36 = __toESM(require_react());
var import_prop_types27 = __toESM(require_prop_types());

// node_modules/@mui/x-charts/Gauge/GaugeProvider.js
var React35 = __toESM(require_react());

// node_modules/@mui/x-charts/Gauge/utils.js
function deg2rad(angle) {
  return Math.PI * angle / 180;
}
function getPoint(angle) {
  const radAngle = deg2rad(angle);
  return [Math.sin(radAngle), -Math.cos(radAngle)];
}
function getArcRatios(startAngle, endAngle) {
  const points = [[0, 0], getPoint(startAngle), getPoint(endAngle)];
  const minAngle = Math.min(startAngle, endAngle);
  const maxAngle = Math.max(startAngle, endAngle);
  const initialAngle = Math.floor(minAngle / 90) * 90;
  for (let step = 1; step <= 4; step += 1) {
    const cardinalAngle = initialAngle + step * 90;
    if (cardinalAngle < maxAngle) {
      points.push(getPoint(cardinalAngle));
    }
  }
  const minX = Math.min(...points.map(([x]) => x));
  const maxX = Math.max(...points.map(([x]) => x));
  const minY = Math.min(...points.map(([, y]) => y));
  const maxY = Math.max(...points.map(([, y]) => y));
  return {
    cx: -minX / (maxX - minX),
    cy: -minY / (maxY - minY),
    minX,
    maxX,
    minY,
    maxY
  };
}
function getAvailableRadius(cx, cy, width, height, {
  minX,
  maxX,
  minY,
  maxY
}) {
  return Math.min(...[{
    ratio: Math.abs(minX),
    space: cx
  }, {
    ratio: Math.abs(maxX),
    space: width - cx
  }, {
    ratio: Math.abs(minY),
    space: cy
  }, {
    ratio: Math.abs(maxY),
    space: height - cy
  }].map(({
    ratio,
    space
  }) => {
    if (ratio < 1e-5) {
      return Infinity;
    }
    return space / ratio;
  }));
}

// node_modules/@mui/x-charts/Gauge/GaugeProvider.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime());
var GaugeContext = React35.createContext({
  value: null,
  valueMin: 0,
  valueMax: 0,
  startAngle: 0,
  endAngle: 0,
  innerRadius: 0,
  outerRadius: 0,
  cornerRadius: 0,
  cx: 0,
  cy: 0,
  maxRadius: 0,
  valueAngle: null
});
if (true) {
  GaugeContext.displayName = "GaugeContext";
}
function GaugeProvider(props) {
  const {
    value = null,
    valueMin = 0,
    valueMax = 100,
    startAngle = 0,
    endAngle = 360,
    outerRadius: outerRadiusParam,
    innerRadius: innerRadiusParam,
    cornerRadius: cornerRadiusParam,
    cx: cxParam,
    cy: cyParam,
    children
  } = props;
  const {
    left,
    top,
    width,
    height
  } = useDrawingArea();
  const ratios = getArcRatios(startAngle, endAngle);
  const innerCx = cxParam ? getPercentageValue(cxParam, width) : ratios.cx * width;
  const innerCy = cyParam ? getPercentageValue(cyParam, height) : ratios.cy * height;
  let cx = left + innerCx;
  let cy = top + innerCy;
  const maxRadius = getAvailableRadius(innerCx, innerCy, width, height, ratios);
  if (cxParam === void 0) {
    const usedWidth = maxRadius * (ratios.maxX - ratios.minX);
    cx = left + (width - usedWidth) / 2 + ratios.cx * usedWidth;
  }
  if (cyParam === void 0) {
    const usedHeight = maxRadius * (ratios.maxY - ratios.minY);
    cy = top + (height - usedHeight) / 2 + ratios.cy * usedHeight;
  }
  const outerRadius = getPercentageValue(outerRadiusParam ?? maxRadius, maxRadius);
  const innerRadius = getPercentageValue(innerRadiusParam ?? "80%", maxRadius);
  const cornerRadius = getPercentageValue(cornerRadiusParam ?? 0, outerRadius - innerRadius);
  const contextValue = React35.useMemo(() => {
    const startAngleRad = Math.PI * startAngle / 180;
    const endAngleRad = Math.PI * endAngle / 180;
    return {
      value,
      valueMin,
      valueMax,
      startAngle: startAngleRad,
      endAngle: endAngleRad,
      outerRadius,
      innerRadius,
      cornerRadius,
      cx,
      cy,
      maxRadius,
      valueAngle: value === null ? null : startAngleRad + (endAngleRad - startAngleRad) * (value - valueMin) / (valueMax - valueMin)
    };
  }, [value, valueMin, valueMax, startAngle, endAngle, outerRadius, innerRadius, cornerRadius, cx, cy, maxRadius]);
  return (0, import_jsx_runtime34.jsx)(GaugeContext.Provider, {
    value: contextValue,
    children
  });
}
function useGaugeState() {
  return React35.useContext(GaugeContext);
}

// node_modules/@mui/x-charts/Gauge/GaugeContainer.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime());
var _excluded24 = ["width", "height", "margin", "title", "desc", "value", "valueMin", "valueMax", "startAngle", "endAngle", "outerRadius", "innerRadius", "cornerRadius", "cx", "cy", "children"];
var ResizableContainer = styled_default("div", {
  name: "MuiGauge",
  slot: "Container"
})(({
  ownerState,
  theme
}) => ({
  width: ownerState.width ?? "100%",
  height: ownerState.height ?? "100%",
  display: "flex",
  position: "relative",
  flexGrow: 1,
  flexDirection: "column",
  alignItems: "center",
  justifyContent: "center",
  overflow: "hidden",
  "&>svg": {
    width: "100%",
    height: "100%"
  },
  "& text": {
    fill: (theme.vars || theme).palette.text.primary
  }
}));
var GaugeContainer = React36.forwardRef(function GaugeContainer2(props, ref) {
  const {
    width: inWidth,
    height: inHeight,
    margin,
    title,
    desc,
    value,
    valueMin = 0,
    valueMax = 100,
    startAngle,
    endAngle,
    outerRadius,
    innerRadius,
    cornerRadius,
    cx,
    cy,
    children
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded24);
  const {
    containerRef,
    width,
    height
  } = useChartContainerDimensions(inWidth, inHeight);
  const svgRef = React36.useRef(null);
  const chartSurfaceRef = useForkRef(ref, svgRef);
  return (0, import_jsx_runtime35.jsx)(ResizableContainer, _extends({
    ref: containerRef,
    ownerState: {
      width: inWidth,
      height: inHeight
    },
    role: "meter",
    "aria-valuenow": value === null ? void 0 : value,
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax
  }, other, {
    children: width && height ? (0, import_jsx_runtime35.jsx)(DrawingProvider, {
      width,
      height,
      margin: _extends({
        left: 10,
        right: 10,
        top: 10,
        bottom: 10
      }, margin),
      svgRef,
      children: (0, import_jsx_runtime35.jsx)(GaugeProvider, {
        value,
        valueMin,
        valueMax,
        startAngle,
        endAngle,
        outerRadius,
        innerRadius,
        cornerRadius,
        cx,
        cy,
        children: (0, import_jsx_runtime35.jsx)(ChartsSurface, {
          width,
          height,
          ref: chartSurfaceRef,
          title,
          desc,
          disableAxisListener: true,
          "aria-hidden": "true",
          children
        })
      })
    }) : null
  }));
});
true ? GaugeContainer.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types27.default.node,
  className: import_prop_types27.default.string,
  /**
   * The radius applied to arc corners (similar to border radius).
   * Set it to '50%' to get rounded arc.
   * @default 0
   */
  cornerRadius: import_prop_types27.default.oneOfType([import_prop_types27.default.number, import_prop_types27.default.string]),
  /**
   * The x coordinate of the arc center.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the width the drawing area.
   */
  cx: import_prop_types27.default.oneOfType([import_prop_types27.default.number, import_prop_types27.default.string]),
  /**
   * The y coordinate of the arc center.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the height the drawing area.
   */
  cy: import_prop_types27.default.oneOfType([import_prop_types27.default.number, import_prop_types27.default.string]),
  desc: import_prop_types27.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types27.default.bool,
  /**
   * The end angle (deg).
   * @default 360
   */
  endAngle: import_prop_types27.default.number,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types27.default.number,
  /**
   * The radius between circle center and the beginning of the arc.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the maximal radius that fit into the drawing area.
   * @default '80%'
   */
  innerRadius: import_prop_types27.default.oneOfType([import_prop_types27.default.number, import_prop_types27.default.string]),
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types27.default.shape({
    bottom: import_prop_types27.default.number,
    left: import_prop_types27.default.number,
    right: import_prop_types27.default.number,
    top: import_prop_types27.default.number
  }),
  /**
   * The radius between circle center and the end of the arc.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the maximal radius that fit into the drawing area.
   * @default '100%'
   */
  outerRadius: import_prop_types27.default.oneOfType([import_prop_types27.default.number, import_prop_types27.default.string]),
  /**
   * The start angle (deg).
   * @default 0
   */
  startAngle: import_prop_types27.default.number,
  sx: import_prop_types27.default.oneOfType([import_prop_types27.default.arrayOf(import_prop_types27.default.oneOfType([import_prop_types27.default.func, import_prop_types27.default.object, import_prop_types27.default.bool])), import_prop_types27.default.func, import_prop_types27.default.object]),
  title: import_prop_types27.default.string,
  /**
   * The value of the gauge.
   * Set to `null` to not display a value.
   */
  value: import_prop_types27.default.number,
  /**
   * The maximal value of the gauge.
   * @default 100
   */
  valueMax: import_prop_types27.default.number,
  /**
   * The minimal value of the gauge.
   * @default 0
   */
  valueMin: import_prop_types27.default.number,
  viewBox: import_prop_types27.default.shape({
    height: import_prop_types27.default.number,
    width: import_prop_types27.default.number,
    x: import_prop_types27.default.number,
    y: import_prop_types27.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types27.default.number
} : void 0;

// node_modules/@mui/x-charts/Gauge/GaugeValueArc.js
var React37 = __toESM(require_react());
var import_jsx_runtime36 = __toESM(require_jsx_runtime());
var StyledPath = styled_default("path", {
  name: "MuiGauge",
  slot: "ReferenceArc",
  overridesResolver: (props, styles) => styles.referenceArc
})(({
  theme
}) => ({
  fill: (theme.vars || theme).palette.primary.main
}));
function GaugeValueArc(props) {
  const {
    value,
    valueMin,
    valueMax,
    startAngle,
    endAngle,
    outerRadius,
    innerRadius,
    cornerRadius,
    cx,
    cy
  } = useGaugeState();
  if (value === null) {
    return null;
  }
  const valueAngle = startAngle + (value - valueMin) / (valueMax - valueMin) * (endAngle - startAngle);
  return (0, import_jsx_runtime36.jsx)(StyledPath, _extends({
    transform: `translate(${cx}, ${cy})`,
    d: arc_default().cornerRadius(cornerRadius)({
      startAngle,
      endAngle: valueAngle,
      innerRadius,
      outerRadius
    })
  }, props));
}

// node_modules/@mui/x-charts/Gauge/GaugeReferenceArc.js
var React38 = __toESM(require_react());
var import_jsx_runtime37 = __toESM(require_jsx_runtime());
var StyledPath2 = styled_default("path", {
  name: "MuiGauge",
  slot: "ReferenceArc",
  overridesResolver: (props, styles) => styles.referenceArc
})(({
  theme
}) => ({
  fill: (theme.vars || theme).palette.divider
}));
function GaugeReferenceArc(props) {
  const {
    startAngle,
    endAngle,
    outerRadius,
    innerRadius,
    cornerRadius,
    cx,
    cy
  } = useGaugeState();
  return (0, import_jsx_runtime37.jsx)(StyledPath2, _extends({
    transform: `translate(${cx}, ${cy})`,
    d: arc_default().cornerRadius(cornerRadius)({
      startAngle,
      endAngle,
      innerRadius,
      outerRadius
    })
  }, props));
}

// node_modules/@mui/x-charts/Gauge/gaugeClasses.js
function getGaugeUtilityClass(slot) {
  return generateUtilityClass("MuiGauge", slot);
}
var gaugeClasses = generateUtilityClasses("MuiGauge", ["root", "valueArc", "referenceArc", "valueText"]);

// node_modules/@mui/x-charts/Gauge/GaugeValueText.js
var React39 = __toESM(require_react());
var import_prop_types28 = __toESM(require_prop_types());
var import_jsx_runtime38 = __toESM(require_jsx_runtime());
var _excluded25 = ["text", "className"];
function defaultFormatter({
  value
}) {
  return value === null ? null : value.toLocaleString();
}
function GaugeValueText(props) {
  const {
    text = defaultFormatter,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded25);
  const {
    value,
    valueMin,
    valueMax,
    cx,
    cy
  } = useGaugeState();
  const formattedText = typeof text === "function" ? text({
    value,
    valueMin,
    valueMax
  }) : text;
  if (formattedText === null) {
    return null;
  }
  return (0, import_jsx_runtime38.jsx)("g", {
    className,
    children: (0, import_jsx_runtime38.jsx)(ChartsText, _extends({
      x: cx,
      y: cy,
      text: formattedText,
      style: {
        textAnchor: "middle",
        dominantBaseline: "central"
      }
    }, other))
  });
}
true ? GaugeValueText.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Height of a text line (in `em`).
   */
  lineHeight: import_prop_types28.default.number,
  /**
   * If `true`, the line width is computed.
   * @default false
   */
  needsComputation: import_prop_types28.default.bool,
  ownerState: import_prop_types28.default.any,
  /**
   * Style applied to text elements.
   */
  style: import_prop_types28.default.object,
  text: import_prop_types28.default.oneOfType([import_prop_types28.default.func, import_prop_types28.default.string])
} : void 0;

// node_modules/@mui/x-charts/Gauge/Gauge.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime());
var _excluded26 = ["text", "children", "classes", "className"];
var useUtilityClasses8 = (props) => {
  const {
    classes
  } = props;
  const slots = {
    root: ["root"],
    valueArc: ["valueArc"],
    referenceArc: ["referenceArc"],
    valueText: ["valueText"]
  };
  return composeClasses(slots, getGaugeUtilityClass, classes);
};
var Gauge = React40.forwardRef(function Gauge2(props, ref) {
  const {
    text,
    children,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded26);
  const classes = useUtilityClasses8(props);
  return (0, import_jsx_runtime39.jsxs)(GaugeContainer, _extends({}, other, {
    className: clsx_default(classes.root, className),
    ref,
    children: [(0, import_jsx_runtime39.jsx)(GaugeReferenceArc, {
      className: classes.referenceArc
    }), (0, import_jsx_runtime39.jsx)(GaugeValueArc, {
      className: classes.valueArc
    }), (0, import_jsx_runtime39.jsx)(GaugeValueText, {
      className: classes.valueText,
      text
    }), children]
  }));
});
true ? Gauge.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types29.default.node,
  classes: import_prop_types29.default.object,
  className: import_prop_types29.default.string,
  /**
   * The radius applied to arc corners (similar to border radius).
   * Set it to '50%' to get rounded arc.
   * @default 0
   */
  cornerRadius: import_prop_types29.default.oneOfType([import_prop_types29.default.number, import_prop_types29.default.string]),
  /**
   * The x coordinate of the arc center.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the width the drawing area.
   */
  cx: import_prop_types29.default.oneOfType([import_prop_types29.default.number, import_prop_types29.default.string]),
  /**
   * The y coordinate of the arc center.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the height the drawing area.
   */
  cy: import_prop_types29.default.oneOfType([import_prop_types29.default.number, import_prop_types29.default.string]),
  desc: import_prop_types29.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types29.default.bool,
  /**
   * The end angle (deg).
   * @default 360
   */
  endAngle: import_prop_types29.default.number,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types29.default.number,
  /**
   * The radius between circle center and the beginning of the arc.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the maximal radius that fit into the drawing area.
   * @default '80%'
   */
  innerRadius: import_prop_types29.default.oneOfType([import_prop_types29.default.number, import_prop_types29.default.string]),
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types29.default.shape({
    bottom: import_prop_types29.default.number,
    left: import_prop_types29.default.number,
    right: import_prop_types29.default.number,
    top: import_prop_types29.default.number
  }),
  /**
   * The radius between circle center and the end of the arc.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the maximal radius that fit into the drawing area.
   * @default '100%'
   */
  outerRadius: import_prop_types29.default.oneOfType([import_prop_types29.default.number, import_prop_types29.default.string]),
  /**
   * The start angle (deg).
   * @default 0
   */
  startAngle: import_prop_types29.default.number,
  sx: import_prop_types29.default.oneOfType([import_prop_types29.default.arrayOf(import_prop_types29.default.oneOfType([import_prop_types29.default.func, import_prop_types29.default.object, import_prop_types29.default.bool])), import_prop_types29.default.func, import_prop_types29.default.object]),
  text: import_prop_types29.default.oneOfType([import_prop_types29.default.func, import_prop_types29.default.string]),
  title: import_prop_types29.default.string,
  /**
   * The value of the gauge.
   * Set to `null` to not display a value.
   */
  value: import_prop_types29.default.number,
  /**
   * The maximal value of the gauge.
   * @default 100
   */
  valueMax: import_prop_types29.default.number,
  /**
   * The minimal value of the gauge.
   * @default 0
   */
  valueMin: import_prop_types29.default.number,
  viewBox: import_prop_types29.default.shape({
    height: import_prop_types29.default.number,
    width: import_prop_types29.default.number,
    x: import_prop_types29.default.number,
    y: import_prop_types29.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types29.default.number
} : void 0;
export {
  AnimatedArea,
  AnimatedLine,
  AreaElement,
  AreaElementPath,
  AreaPlot,
  BarChart,
  BarElement,
  BarElementPath,
  BarLabel,
  BarPlot,
  ChartContainer,
  ChartsAxis,
  ChartsAxisHighlight,
  ChartsAxisHighlightPath,
  ChartsAxisTooltipContent,
  ChartsClipPath,
  ChartsGrid,
  ChartsItemTooltipContent,
  ChartsLegend,
  ChartsOnAxisClickHandler,
  ChartsReferenceLine,
  ChartsSurface,
  ChartsText,
  ChartsTooltip,
  ChartsTooltipCell,
  ChartsTooltipMark,
  ChartsTooltipPaper,
  ChartsTooltipRow,
  ChartsTooltipTable,
  ChartsVoronoiHandler,
  ChartsXAxis,
  ChartsYAxis,
  ContinuousColorLegend,
  DEFAULT_MARGINS,
  DEFAULT_X_AXIS_KEY,
  DEFAULT_Y_AXIS_KEY,
  DefaultChartsAxisTooltipContent,
  DefaultChartsItemTooltipContent,
  DefaultChartsLegend,
  Gauge,
  GaugeContainer,
  GaugeReferenceArc,
  GaugeValueArc,
  GaugeValueText,
  HighlightedContext,
  HighlightedProvider,
  LineChart,
  LineElement,
  LineElementPath,
  LineHighlightElement,
  LineHighlightPlot,
  LinePlot,
  MarkElement,
  MarkPlot,
  PieArc,
  PieArcLabel,
  PieArcLabelPlot,
  PieArcPlot,
  PieChart,
  PiePlot,
  PiecewiseColorLegend,
  ResponsiveChartContainer,
  Scatter,
  ScatterChart,
  ScatterPlot,
  SparkLineChart,
  ZAxisContextProvider,
  areaElementClasses,
  axisClasses,
  barElementClasses,
  barLabelClasses,
  blueberryTwilightPalette,
  blueberryTwilightPaletteDark,
  blueberryTwilightPaletteLight,
  chartsAxisHighlightClasses,
  chartsGridClasses,
  chartsTooltipClasses,
  cheerfulFiestaPalette,
  cheerfulFiestaPaletteDark,
  cheerfulFiestaPaletteLight,
  gaugeClasses,
  getAreaElementUtilityClass,
  getAxisHighlightUtilityClass,
  getAxisUtilityClass,
  getBarElementUtilityClass,
  getBarLabelUtilityClass,
  getChartsGridUtilityClass,
  getChartsTooltipUtilityClass,
  getGaugeUtilityClass,
  getHighlightElementUtilityClass,
  getLegendUtilityClass,
  getLineElementUtilityClass,
  getMarkElementUtilityClass,
  getPieArcLabelUtilityClass,
  getPieArcUtilityClass,
  getPieCoordinates,
  getReferenceLineUtilityClass,
  getSeriesToDisplay,
  getValueToPositionMapper,
  isBarSeries,
  isDefaultizedBarSeries,
  legendClasses,
  lineElementClasses,
  lineHighlightElementClasses,
  mangoFusionPalette,
  mangoFusionPaletteDark,
  mangoFusionPaletteLight,
  markElementClasses,
  pieArcClasses,
  pieArcLabelClasses,
  referenceLineClasses,
  useBarSeries as unstable_useBarSeries,
  useLineSeries as unstable_useLineSeries,
  usePieSeries as unstable_usePieSeries,
  useScatterSeries as unstable_useScatterSeries,
  useSeries as unstable_useSeries,
  useAxisTooltip,
  useChartId,
  useDrawingArea,
  useGaugeState,
  useHighlighted,
  useItemHighlighted,
  useItemTooltip,
  useMouseTracker,
  useSvgRef,
  useXAxis,
  useXColorScale,
  useXScale,
  useYAxis,
  useYColorScale,
  useYScale,
  useZColorScale
};
/*! Bundled license information:

@mui/x-charts/index.js:
  (**
   * @mui/x-charts v7.22.3
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@mui_x-charts.js.map
